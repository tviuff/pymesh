{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to The PyMesh Docs","text":"<p>The PyMesh package handles basic geometry and facilitates the creation of 3-dimensional surface panels. These surface panels are converted into a low-order geometric data file for import and use in WAMIT.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Getting Started<ul> <li>Package at a Glance</li> <li>Installation</li> <li>How-To-Guides</li> <li>Examples</li> </ul> </li> <li>Documentation<ul> <li>API</li> <li>API (auto-generated)</li> </ul> </li> <li>Development<ul> <li>ULM Diagrams<ul> <li>Curves</li> <li>Mesh Distributions</li> </ul> </li> </ul> </li> <li>About<ul> <li>The Project</li> <li>Acknowledgements</li> </ul> </li> </ul>"},{"location":"about/acknowledgements/","title":"Acknowledgements","text":"<p>The various surface algorithms are based on lectures 48 and 49 from the Lecture Series on Computer Aided Design by Dr. Anoop Chawla and P.V. Madhusudan Rao at the Department of Mechanical Engineering, IIT Delhi.</p> <p>The implementation of the <code>ArcPVA</code> curve path algoithm, as well as all curve <code>rotate</code> methods, allows for rotation of a vector around another. The current code implementation is based on Rodrigues' rotation formula.</p> <p>The curve <code>mirror</code> method returns a mirror image of the object, mirrored in a plane defined by a point and a normal vector. The implementation is based on code by Jean Marie.</p> <p>During work on the <code>PyMesh</code> package, inspiration and guidance has come from various sources. Notable parties are ArjanCodes, Corey Schafer and Michael Viuff.</p>"},{"location":"about/the-project/","title":"The Project","text":"<p>The <code>PyMesh</code> project is the first attempt of a package made by tviuff. The idea behind the package came when working on a floating wind turbine (FWT) concept and having to defined the FWT geometry as part of the hydrodynamic wave load analysis in WAMIT. At the time, no input low-order geometric data file (GDF) was available and so the geometry was made using functional programming, based on project-specified dimensions. Ever since then, the idea of creating a simpe API for generating simple geometries and converting them to low-order geometric data files was born.</p>"},{"location":"dev/","title":"Development Site","text":"<p>Reference page for developers. So far the page only reflects the package structure via class diagrams. These are shown in the Unified Language Model (ULM).</p>"},{"location":"dev/curves/","title":"Curves","text":"<pre><code>classDiagram\n    class Curve{\n        +Point start\n        +Point end\n        +get_path() Callable\n        +length()*\n        +path() NDArray3*\n        +copy() Curve*\n        +move() Curve*\n        +rotate() Curve*\n        +mirror() Curve*\n    }\n    &lt;&lt;Interface&gt;&gt; Curve\n    Curve &lt;|-- Line : Inheritance\n    Curve &lt;|-- Arc3P : Inheritance\n    Curve &lt;|-- ArcPVA : Inheritance\n    Curve &lt;|-- Bezier : Inheritance\n    Curve &lt;|-- UserDefinedCurve : Inheritance\n    class Line{\n        +__init__(start, end)\n    }\n    class Arc3P{\n        +Point centre\n        +bool inverse_sector\n        +__init__(centre, start, end)\n    }\n    class ArcPVA{\n        +float angle\n        +float a\n        +float b\n        +float c\n        +float x0\n        +float y0\n        +float z0\n        +__init__(start, a, b, c, x0, y0, z0)\n    }\n    class Bezier{\n        +list~Point~ points\n        +__init__(points)\n    }\n    class UserDefinedCurve{\n        -Callable path\n        +__init__(path)\n    }</code></pre>"},{"location":"dev/mesh_distributions/","title":"Mesh Distributions","text":"<pre><code>classDiagram\n    class MeshDistribution{\n        +bool flip_direction\n        +copy() MeshDistribution*\n        +get_dist_fn() Callable*\n        +flip_exp() None\n        +validate_fn_input() None\n    }\n    &lt;&lt;Interface&gt;&gt; MeshDistribution\n    MeshDistribution &lt;|-- LinearDistribution : Inheritance\n    MeshDistribution &lt;|-- CosineDistribution : Inheritance\n    MeshDistribution &lt;|-- ExponentialDistribution : Inheritance\n    MeshDistribution &lt;|-- PowerDistribution : Inheritance\n    class LinearDistribution{\n        +copy() LinearDistribution\n        +get_dist_fn() Callable\n    }\n    class CosineDistribution{\n        +copy() CosineDistribution\n        +get_dist_fn() Callable\n    }\n    class ExponentialDistribution{\n        +copy() ExponentialDistribution\n        +get_dist_fn() Callable\n    }\n    class PowerDistribution{\n        +copy() PowerDistribution\n        +get_dist_fn() Callable\n    }</code></pre>"},{"location":"doc-pages/","title":"Documentation","text":"<p>Contains API documentation.</p>"},{"location":"doc-pages/Arc3P/","title":"ArcP3","text":"<p>               Bases: <code>Curve</code></p> <p>Creates an arc curve object, generated from three points in space.</p> <p>Implementation based on WikiPedia. For more information, see Curve documentation.</p> <p>Parameters:</p> Name Type Description Default <code>centre</code> <code>Point</code> <p>Arc center point</p> required <code>inverse_sector</code> <code>bool</code> <p>Specifies if to use the outer (True) or inner (False) sector of the swept circle. Defaults to False.</p> <code>False</code> Source code in <code>pymesh/geo/curves/arc3p.py</code> <pre><code>class Arc3P(Curve):\n    \"\"\"Creates an arc curve object, generated from three points in space.\n\n    Implementation based on [WikiPedia](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n    For more information, see Curve documentation.\n\n    Args:\n        centre (Point): Arc center point\n        inverse_sector (bool): Specifies if to use the outer\n            (True) or inner (False) sector of the swept circle.\n            Defaults to False.\n    \"\"\"\n\n    centre = AsInstanceOf(Point)\n    inverse_sector = AsInstanceOf(bool)\n\n    def __init__(\n        self,\n        centre: Point,\n        start: Point,\n        end: Point,\n        inverse_sector: bool = False,\n    ):\n        \"\"\"Initialization method.\n\n        Args:\n            centre: Arc center point\n            start: Arc start point\n            end: Arc end point\n            inverse_sector: Specifies if to use the outer (True)\n                or inner (False) sector of the swept circle.\n                Defaults to False.\n\n        Raises:\n            ValueError: If the start and end points are located\n                at different radii from the centre point.\n            ValueError: If cross product of the centre-to-start\n                and centre-to-end vectors is zero.\n        \"\"\"\n        self.centre = centre\n        self.start = start\n        self.end = end\n        self.inverse_sector = inverse_sector\n        validate_radii_and_cross_product(centre, start, end)\n\n    def __eq__(self, other):\n        return (\n            self.centre == other.centre\n            and self.start == other.start\n            and self.end == other.end\n        )\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __repr__(self):\n        cls = type(self).__name__\n        c, s, e, i = self.centre, self.start, self.end, self.inverse_sector\n        return f\"{cls}(centre={c}, start={s}, end={e}, inverse_sector={i})\"\n\n    def copy(self) -&gt; Self:\n        return Arc3P(\n            self.centre.copy(), self.start.copy(), self.end.copy(), self.inverse_sector\n        )\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.centre.move(dx, dy, dz)\n        self.start.move(dx, dy, dz)\n        self.end.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.centre.rotate(angle, a, b, c, x0, y0, z0)\n        self.start.rotate(angle, a, b, c, x0, y0, z0)\n        self.end.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.centre.mirror(a, b, c, x0, y0, z0)\n        self.start.mirror(a, b, c, x0, y0, z0)\n        self.end.mirror(a, b, c, x0, y0, z0)\n        return self\n\n    @property\n    def radius(self) -&gt; float:\n        return np.sqrt(np.sum((self.start - self.centre) ** 2))\n\n    @property\n    def cross_product(self) -&gt; NDArray3[np.float64]:\n        sign = -1 if self.inverse_sector else 1\n        return sign * np.cross((self.start - self.centre), (self.end - self.centre))\n\n    @property\n    def plane_unit_normal(self) -&gt; NDArray3[np.float64]:\n        return self.cross_product / np.sqrt(np.sum(self.cross_product**2))\n\n    @property\n    def angle(self) -&gt; float:\n        angle = np.arccos(\n            np.dot((self.start - self.centre), (self.end - self.centre))\n            / (self.radius**2)\n        )\n        angle = 2 * math.pi - angle if self.inverse_sector else angle\n        return angle\n\n    @property\n    def length(self) -&gt; float:\n        return self.radius * self.angle\n\n    def path(self, u: int | float, flip: bool = False) -&gt; NDArray3[np.float64]:\n        u = validate_curve_path_parameters(u, flip)\n        v, k, a = (self.start - self.centre), self.plane_unit_normal, self.angle\n        xyz0 = self.centre.xyz\n        part1 = v * math.cos(a * u)\n        part2 = np.cross(k, v) * math.sin(a * u)\n        part3 = k * np.dot(k, v) * (1 - math.cos(a * u))\n        return xyz0 + part1 + part2 + part3\n</code></pre>"},{"location":"doc-pages/Arc3P/#pymesh.geo.curves.arc3p.Arc3P.__init__","title":"__init__","text":"<pre><code>__init__(centre, start, end, inverse_sector=False)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>centre</code> <code>Point</code> <p>Arc center point</p> required <code>start</code> <code>Point</code> <p>Arc start point</p> required <code>end</code> <code>Point</code> <p>Arc end point</p> required <code>inverse_sector</code> <code>bool</code> <p>Specifies if to use the outer (True) or inner (False) sector of the swept circle. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the start and end points are located at different radii from the centre point.</p> <code>ValueError</code> <p>If cross product of the centre-to-start and centre-to-end vectors is zero.</p> Source code in <code>pymesh/geo/curves/arc3p.py</code> <pre><code>def __init__(\n    self,\n    centre: Point,\n    start: Point,\n    end: Point,\n    inverse_sector: bool = False,\n):\n    \"\"\"Initialization method.\n\n    Args:\n        centre: Arc center point\n        start: Arc start point\n        end: Arc end point\n        inverse_sector: Specifies if to use the outer (True)\n            or inner (False) sector of the swept circle.\n            Defaults to False.\n\n    Raises:\n        ValueError: If the start and end points are located\n            at different radii from the centre point.\n        ValueError: If cross product of the centre-to-start\n            and centre-to-end vectors is zero.\n    \"\"\"\n    self.centre = centre\n    self.start = start\n    self.end = end\n    self.inverse_sector = inverse_sector\n    validate_radii_and_cross_product(centre, start, end)\n</code></pre>"},{"location":"doc-pages/ArcPVA/","title":"ArcPVA","text":"<p>               Bases: <code>Curve</code></p> <p>Creates a circular arc based on a point, a vector axis of rotation and an angle.</p> <p>Attributes:</p> Name Type Description <code>angle</code> <code>int | float</code> <p>Angle in radians. Positive direction defined as counter-clockwise, based on the right-hand rule.</p> <code>a</code> <code>int | float</code> <p>Axis vector x direction.</p> <code>b</code> <code>int | float</code> <p>Axis vector y direction.</p> <code>c</code> <code>int | float</code> <p>Axis vector z direction.</p> <code>x0</code> <code>int | float</code> <p>Axis base x coordinate, default is zero.</p> <code>y0</code> <code>int | float</code> <p>Axis base y coordinate, default is zero.</p> <code>z0</code> <code>int | float</code> <p>Axis base z coordinate, default is zero.</p> Source code in <code>pymesh/geo/curves/arcpva.py</code> <pre><code>class ArcPVA(Curve):\n    \"\"\"Creates a circular arc based on a point, a vector axis of rotation and an angle.\n\n    Attributes:\n        angle (int | float): Angle in radians.\n            Positive direction defined as counter-clockwise, based on the right-hand rule.\n        a (int | float): Axis vector x direction.\n        b (int | float): Axis vector y direction.\n        c (int | float): Axis vector z direction.\n        x0 (int | float): Axis base x coordinate, default is zero.\n        y0 (int | float): Axis base y coordinate, default is zero.\n        z0 (int | float): Axis base z coordinate, default is zero.\n    \"\"\"\n\n    angle = AsNumber(return_type=float)\n    a = AsNumber(return_type=float)\n    b = AsNumber(return_type=float)\n    c = AsNumber(return_type=float)\n    x0 = AsNumber(return_type=float)\n    y0 = AsNumber(return_type=float)\n    z0 = AsNumber(return_type=float)\n\n    def __init__(\n        self,\n        start: Point,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ):\n        \"\"\"Initialization method.\n\n        Args:\n            start: Point being rotated around the vector.\n            angle: Angle in radians.\n                Positive direction defined as counter-clockwise, based on the right-hand rule.\n            a: Axis vector x direction.\n            b: Axis vector y direction.\n            c: Axis vector z direction.\n            x0: Axis base x coordinate, default is zero.\n            y0: Axis base y coordinate, default is zero.\n            z0: Axis base z coordinate, default is zero.\n        \"\"\"\n        self.start = start\n        self.angle = angle\n        self.a = a\n        self.b = b\n        self.c = c\n        self.x0 = x0\n        self.y0 = y0\n        self.z0 = z0\n\n    @property\n    def end(self) -&gt; NDArray3[np.float64]:\n        x, y, z = self.path(1)\n        return Point(x, y, z)\n\n    def __eq__(self, other):\n        DECIMALS = 10\n        is_equal = True\n        for u in np.linspace(0, 1, num=100, endpoint=True):\n            u_self = np.all(np.round(self.path(u), decimals=DECIMALS))\n            u_other = np.all(np.round(other.path(u), decimals=DECIMALS))\n            if u_self != u_other:\n                is_equal = False\n                break\n        return is_equal\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __repr__(self):\n        cls = type(self).__name__\n        txt = (\n            f\"{cls}(start={self.start!r}, angle={self.angle:.2f}, \"\n            f\"a={self.a:.2f}, b={self.b:.2f}, c={self.c:.2f}, \"\n            f\"x0={self.x0:.2f}, y0={self.y0:.2f}, z0={self.z0:.2f})\"\n        )\n        return txt\n\n    @property\n    def radius(self) -&gt; float:\n        \"\"\"Returns the arc radius.\"\"\"\n        xyz0 = np.array([self.x0, self.y0, self.z0])\n        a = self.start.xyz - xyz0\n        b = np.array([self.a, self.b, self.c])\n        r = a - np.dot(a, b) / np.dot(b, b) * b\n        return np.sqrt(np.sum(r**2))\n\n    @property\n    def length(self) -&gt; float:\n        return self.radius * self.angle\n\n    def path(self, u: int | float, flip: bool = False) -&gt; NDArray3[np.float64]:\n        u = validate_curve_path_parameters(u, flip)\n        angle = self.angle\n        xyz0 = np.array([self.x0, self.y0, self.z0])\n        abc = np.array([self.a, self.b, self.c])\n        pvec = self.start.xyz - xyz0\n        part1 = pvec * math.cos(angle * u)\n        part2 = np.cross(abc, pvec) * math.sin(angle * u)\n        part3 = abc * np.dot(abc, pvec) * (1 - math.cos(angle * u))\n        return xyz0 + part1 + part2 + part3\n\n    def copy(self) -&gt; Self:\n        return ArcPVA(\n            self.start.copy(),\n            self.angle,\n            self.a,\n            self.b,\n            self.c,\n            self.x0,\n            self.y0,\n            self.z0,\n        )\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.start.move(dx, dy, dz)  # also validates input\n        self.x0 += float(dx)\n        self.y0 += float(dy)\n        self.z0 += float(dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.start.rotate(angle, a, b, c, x0, y0, z0)  # also validates input\n        xyz0 = np.array([self.x0, self.y0, self.z0])\n        xyz0_rotated = rotate_point_xyz(\n            xyz0[0], xyz0[1], xyz0[2], angle, a, b, c, x0, y0, z0\n        )\n        xyz1_rotated = rotate_point_xyz(\n            self.a + x0, self.b + y0, self.c + z0, angle, a, b, c, x0, y0, z0\n        )\n        self.x0, self.y0, self.z0 = xyz0_rotated\n        self.a, self.b, self.c = xyz1_rotated - xyz0\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.start.mirror(a, b, c, x0, y0, z0)  # validates input, should be first\n        xyz0 = np.array([self.x0, self.y0, self.z0])\n        xyz0_mirrored = mirror_point_xyz(xyz0[0], xyz0[1], xyz0[2], a, b, c, x0, y0, z0)\n        xyz1_mirrored = mirror_point_xyz(\n            self.a + x0, self.b + y0, self.c + z0, a, b, c, x0, y0, z0\n        )\n        self.x0, self.y0, self.z0 = xyz0_mirrored\n        self.a, self.b, self.c = xyz1_mirrored - xyz0\n        return self\n</code></pre>"},{"location":"doc-pages/ArcPVA/#pymesh.geo.curves.arcpva.ArcPVA.radius","title":"radius  <code>property</code>","text":"<pre><code>radius\n</code></pre> <p>Returns the arc radius.</p>"},{"location":"doc-pages/ArcPVA/#pymesh.geo.curves.arcpva.ArcPVA.__init__","title":"__init__","text":"<pre><code>__init__(start, angle, a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Point</code> <p>Point being rotated around the vector.</p> required <code>angle</code> <code>int | float</code> <p>Angle in radians. Positive direction defined as counter-clockwise, based on the right-hand rule.</p> required <code>a</code> <code>int | float</code> <p>Axis vector x direction.</p> required <code>b</code> <code>int | float</code> <p>Axis vector y direction.</p> required <code>c</code> <code>int | float</code> <p>Axis vector z direction.</p> required <code>x0</code> <code>int | float</code> <p>Axis base x coordinate, default is zero.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Axis base y coordinate, default is zero.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Axis base z coordinate, default is zero.</p> <code>0.0</code> Source code in <code>pymesh/geo/curves/arcpva.py</code> <pre><code>def __init__(\n    self,\n    start: Point,\n    angle: int | float,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n):\n    \"\"\"Initialization method.\n\n    Args:\n        start: Point being rotated around the vector.\n        angle: Angle in radians.\n            Positive direction defined as counter-clockwise, based on the right-hand rule.\n        a: Axis vector x direction.\n        b: Axis vector y direction.\n        c: Axis vector z direction.\n        x0: Axis base x coordinate, default is zero.\n        y0: Axis base y coordinate, default is zero.\n        z0: Axis base z coordinate, default is zero.\n    \"\"\"\n    self.start = start\n    self.angle = angle\n    self.a = a\n    self.b = b\n    self.c = c\n    self.x0 = x0\n    self.y0 = y0\n    self.z0 = z0\n</code></pre>"},{"location":"doc-pages/Bezier/","title":"Bezier","text":"<p>               Bases: <code>Curve</code></p> <p>Creates a bezier curve from a collection of three-dimensional points.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>list[Point] | tuple[Point]</code> <p>List or tuple of points.</p> Source code in <code>pymesh/geo/curves/bezier.py</code> <pre><code>class Bezier(Curve):\n    \"\"\"Creates a bezier curve from a collection of three-dimensional points.\n\n    Attributes:\n        points (list[Point] | tuple[Point]): List or tuple of points.\n    \"\"\"\n\n    points = AsContainerOf(tuple, Point, min_length=2)\n\n    def __init__(self, points: list[Point] | tuple[Point]):\n        \"\"\"Initialization method.\n\n        Args:\n            points: List or tuple of points.\n\n        Raises:\n            TypeError: If points is not a list or tuple\n            ValueError: If points has less than two elements.\n            TypeError: If elements of points are not of type Point.\n        \"\"\"\n        if not isinstance(points, (tuple, list)):\n            raise TypeError(f\"{points!r} is not a tuple or list\")\n        self.points = tuple(points)\n\n    def __eq__(self, other):\n        is_equal = True\n        if type(self).__name__ != type(other).__name__:\n            is_equal = False\n        else:\n            for p1, p2 in zip(self.points, other.points):\n                if p1 != p2:\n                    is_equal = False\n                    break\n        return is_equal\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __repr__(self):\n        txt = f\"{type(self).__name__}(points=[\"\n        for i, point in enumerate(self.points):\n            ext = \", \" if i &lt; len(self.points) - 1 else \"])\"\n            txt += f\"{point!r}{ext}\"\n        return txt\n\n    @property\n    def start(self) -&gt; NDArray3[np.float64]:\n        x, y, z = self.path(0)\n        return Point(x, y, z)\n\n    @property\n    def end(self) -&gt; NDArray3[np.float64]:\n        x, y, z = self.path(1)\n        return Point(x, y, z)\n\n    @property\n    def length(self) -&gt; float:\n        distance = 0.0\n        xyz0 = self.path(0)\n        for u in np.linspace(start=0, stop=1, num=NUM_POINTS, endpoint=True):\n            xyz1 = self.path(u)\n            distance += np.sqrt(np.sum((xyz1 - xyz0) ** 2))\n            xyz0 = xyz1\n        return distance\n\n    def path(self, u: int | float, flip: bool = False) -&gt; NDArray3[np.float64]:\n        u = validate_curve_path_parameters(u, flip)\n\n        def bezier(points, t):\n            \"\"\"Recursive bezier curve definition.\n\n            Based on https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Constructing_B%C3%A9zier_curves\n            \"\"\"\n            if len(points) == 1:\n                return points[0].xyz\n            return (1 - t) * bezier(points[0:-1], t) + t * bezier(points[1:], t)\n\n        return bezier(self.points, u)\n\n    def copy(self) -&gt; Self:\n        points = []\n        for point in self.points:\n            points.append(point.copy())\n        return Bezier(points)\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        for point in self.points:\n            point.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        for point in self.points:\n            point.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        for point in self.points:\n            point.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/Bezier/#pymesh.geo.curves.bezier.Bezier.__init__","title":"__init__","text":"<pre><code>__init__(points)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Point] | tuple[Point]</code> <p>List or tuple of points.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If points is not a list or tuple</p> <code>ValueError</code> <p>If points has less than two elements.</p> <code>TypeError</code> <p>If elements of points are not of type Point.</p> Source code in <code>pymesh/geo/curves/bezier.py</code> <pre><code>def __init__(self, points: list[Point] | tuple[Point]):\n    \"\"\"Initialization method.\n\n    Args:\n        points: List or tuple of points.\n\n    Raises:\n        TypeError: If points is not a list or tuple\n        ValueError: If points has less than two elements.\n        TypeError: If elements of points are not of type Point.\n    \"\"\"\n    if not isinstance(points, (tuple, list)):\n        raise TypeError(f\"{points!r} is not a tuple or list\")\n    self.points = tuple(points)\n</code></pre>"},{"location":"doc-pages/BilinearSurface/","title":"BilinearSurface","text":"<p>               Bases: <code>Surface</code></p> <p>Creates a bilinear surface from the points p00, p10, p11 and p01.</p> <p>These four points represent the surface corners going counter-clockwise. The first number represents the value of u, while the second number represents the value of w.</p> <p>Attributes:</p> Name Type Description <code>p00</code> <code>Point</code> <p>Bottom-left point (u=0, w=0).</p> <code>p10</code> <code>Point</code> <p>Bottom-right point (u=1, w=0).</p> <code>p01</code> <code>Point</code> <p>Top-left point (u=0, w=1).</p> <code>p11</code> <code>Point</code> <p>Top-right point (u=1, w=1).</p> Source code in <code>pymesh/geo/surfaces/bilinear_surface.py</code> <pre><code>class BilinearSurface(Surface):\n    \"\"\"Creates a bilinear surface from the points p00, p10, p11 and p01.\n\n    These four points represent the surface corners going counter-clockwise.\n    The first number represents the value of u, while the second number\n    represents the value of w.\n\n    Attributes:\n        p00 (Point): Bottom-left point (u=0, w=0).\n        p10 (Point): Bottom-right point (u=1, w=0).\n        p01 (Point): Top-left point (u=0, w=1).\n        p11 (Point): Top-right point (u=1, w=1).\n    \"\"\"\n\n    p00 = AsInstanceOf(Point)\n    p10 = AsInstanceOf(Point)\n    p01 = AsInstanceOf(Point)\n    p11 = AsInstanceOf(Point)\n\n    def __init__(self, p00: Point, p10: Point, p11: Point, p01: Point):\n        \"\"\"Initialization method.\n\n        Args:\n            p00: Bottom-left point\n            p10: Bottom-right point\n            p01: Top-left point\n            p11: Top-right point\n\n        Raises:\n            TypeError: If p00, p10, p01 or p11 are not of type Point.\n        \"\"\"\n        self._all_surfaces.append(self)\n        self.p00 = p00\n        self.p10 = p10\n        self.p11 = p11\n        self.p01 = p01\n\n    def __eq__(self, other):\n        return (\n            self.p00 == other.p00\n            and self.p10 == other.p10\n            and self.p11 == other.p11\n            and self.p01 == other.p01\n        )\n\n    def __repr__(self):\n        return (\n            f\"{type(self).__name__}(p00={self.p00!r},\"\n            f\"p10={self.p10!r}, p11={self.p11!r}, p01={self.p01!r})\"\n        )\n\n    def path(\n        self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n    ) -&gt; NDArray3[np.float64]:\n        u, w = validate_surface_path_parameters(u, w, uflip, wflip)\n        return (\n            (1 - u) * w * self.p00.xyz\n            + u * w * self.p10.xyz\n            + (1 - u) * (1 - w) * self.p01.xyz\n            + u * (1 - w) * self.p11.xyz\n        )\n\n    def get_max_lengths(self) -&gt; tuple[float]:\n        length_u_bottom = np.sqrt(np.sum((self.p00 - self.p10) ** 2))\n        length_u_top = np.sqrt(np.sum((self.p01 - self.p11) ** 2))\n        length_w_left = np.sqrt(np.sum((self.p00 - self.p01) ** 2))\n        length_w_right = np.sqrt(np.sum((self.p10 - self.p11) ** 2))\n        length_u = float(np.max((length_u_bottom, length_u_top)))\n        length_w = float(np.max((length_w_left, length_w_right)))\n        return length_u, length_w\n\n    def copy(self) -&gt; Self:\n        copy = BilinearSurface(\n            self.p00.copy(),\n            self.p10.copy(),\n            self.p11.copy(),\n            self.p01.copy(),\n        )\n        copy._is_normal_flipped = self._is_normal_flipped\n        return copy\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.p00.move(dx, dy, dz)\n        self.p10.move(dx, dy, dz)\n        self.p11.move(dx, dy, dz)\n        self.p01.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.p00.rotate(angle, a, b, c, x0, y0, z0)\n        self.p10.rotate(angle, a, b, c, x0, y0, z0)\n        self.p11.rotate(angle, a, b, c, x0, y0, z0)\n        self.p01.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.p00.mirror(a, b, c, x0, y0, z0)\n        self.p10.mirror(a, b, c, x0, y0, z0)\n        self.p11.mirror(a, b, c, x0, y0, z0)\n        self.p01.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/BilinearSurface/#pymesh.geo.surfaces.bilinear_surface.BilinearSurface.__init__","title":"__init__","text":"<pre><code>__init__(p00, p10, p11, p01)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>p00</code> <code>Point</code> <p>Bottom-left point</p> required <code>p10</code> <code>Point</code> <p>Bottom-right point</p> required <code>p01</code> <code>Point</code> <p>Top-left point</p> required <code>p11</code> <code>Point</code> <p>Top-right point</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If p00, p10, p01 or p11 are not of type Point.</p> Source code in <code>pymesh/geo/surfaces/bilinear_surface.py</code> <pre><code>def __init__(self, p00: Point, p10: Point, p11: Point, p01: Point):\n    \"\"\"Initialization method.\n\n    Args:\n        p00: Bottom-left point\n        p10: Bottom-right point\n        p01: Top-left point\n        p11: Top-right point\n\n    Raises:\n        TypeError: If p00, p10, p01 or p11 are not of type Point.\n    \"\"\"\n    self._all_surfaces.append(self)\n    self.p00 = p00\n    self.p10 = p10\n    self.p11 = p11\n    self.p01 = p01\n</code></pre>"},{"location":"doc-pages/CoonsPatch/","title":"CoonsPatch","text":"<p>               Bases: <code>Surface</code></p> <p>Creates a Coons Patch from a selection of four curves.</p> <p>Attributes:</p> Name Type Description <code>curves</code> <code>list[Curve] | tuple[Curve]</code> <p>List or tuple with four Curve instances defining the surface boundary curves.</p> Source code in <code>pymesh/geo/surfaces/coons_patch.py</code> <pre><code>class CoonsPatch(Surface):\n    \"\"\"Creates a Coons Patch from a selection of four curves.\n\n    Attributes:\n        curves (list[Curve] | tuple[Curve]): List or tuple with four\n            Curve instances defining the surface boundary curves.\n    \"\"\"\n\n    def __init__(self, curves: list[Curve] | tuple[Curve]):\n        \"\"\"Initialization method.\n\n        Args:\n            curves: List or tuple with four Curve instances\n                defining the surface boundary curves.\n\n        Raises:\n            TypeError: If curves is not of type list or tuple.\n            ValueError: If length of curves is not equal to four.\n            TypeError: If elements of curves are not of type Curve.\n        \"\"\"\n        self._all_surfaces.append(self)\n        self.curves = curves  # also sets self._flipped_curves\n\n    def __eq__(self, other):\n        is_equal = True\n        for scurve, ocurve in zip(self.curves, other.curves):\n            if scurve != ocurve:\n                is_equal = False\n                break\n        return is_equal\n\n    def __repr__(self):\n        txt = f\"{type(self).__name__}(curves=(\"\n        for i, curve in enumerate(self.curves):\n            txt += f\"{curve!r}\"\n            txt += \"))\" if i == 3 else \", \"\n        return txt\n\n    @property\n    def curves(self) -&gt; tuple[Curve]:\n        return self._curves\n\n    @curves.setter\n    def curves(self, curves) -&gt; None:\n        pname = \"curves\"\n        if not isinstance(curves, (list, tuple)):\n            raise TypeError(f\"{pname} must receive a list or tuple input\")\n        if len(curves) != 4:\n            raise ValueError(f\"{pname} must containing exactly 4 items.\")\n        for curve in curves:\n            if not isinstance(curve, Curve):\n                raise TypeError(f\"{pname} items must be of type 'Curve'.\")\n        initial_selection = list(curves)\n        curve_selection = [initial_selection.pop(0)]\n        ref_point = curve_selection[-1].end\n        flipped_curves = [False]\n        index = 0\n        while (\n            len(curve_selection) &lt;= 4\n            and len(initial_selection) &gt;= 1\n            and index &lt; len(initial_selection)\n        ):\n            next_curve_points = (\n                initial_selection[index].start,\n                initial_selection[index].end,\n            )\n            if ref_point == next_curve_points[0] or ref_point == next_curve_points[1]:\n                if np.all(ref_point == next_curve_points[0]):\n                    # next curve has matching starting point\n                    flipped_curves.append(False)\n                    ref_point = next_curve_points[1]\n                else:\n                    # next curve has matching ending point\n                    flipped_curves.append(True)\n                    ref_point = next_curve_points[0]\n                curve_selection.append(initial_selection.pop(index))\n                index = 0\n                continue\n            index += 1\n        if ref_point != curve_selection[0].start or index &gt; len(initial_selection):\n            raise CurveIntersectionError(\n                \"Selected curves does not share intersection points\"\n            )\n        cflip, cselect = set_curve_order(flipped_curves, curve_selection)\n        self._flipped_curves = tuple(cflip)\n        self._curves = tuple(cselect)\n\n    def path(\n        self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n    ) -&gt; NDArray3[np.float64]:\n        u, w = validate_surface_path_parameters(u, w, uflip, wflip)\n        curve_u0, curve_u1, curve_0w, curve_1w = self.curves\n        fu0, fu1, f0w, f1w = self._flipped_curves\n\n        def path_u0(x):\n            return curve_u0.path(x, flip=fu0)\n\n        def path_u1(x):\n            return curve_u1.path(x, flip=fu1)\n\n        def path_0w(x):\n            return curve_0w.path(x, flip=f0w)\n\n        def path_1w(x):\n            return curve_1w.path(x, flip=f1w)\n\n        p00, p11, p01, p10 = path_u0(0), path_u1(1), path_0w(1), path_1w(0)\n        p1 = (1 - u) * path_0w(w) + u * path_1w(w)\n        p2 = (1 - w) * path_u0(u) + w * path_u1(u)\n        p3 = (\n            (1 - u) * (1 - w) * p00\n            + u * (1 - w) * p10\n            + (1 - u) * w * p01\n            + u * w * p11\n        )\n        return p1 + p2 - p3\n\n    def get_max_lengths(self) -&gt; tuple[float]:\n        curve_u0, curve_u1, curve_0w, curve_1w = self.curves\n        max_length_u = max(curve_u0.length, curve_u1.length)\n        max_length_w = max(curve_0w.length, curve_1w.length)\n        return max_length_u, max_length_w\n\n    def copy(self) -&gt; Self:\n        curve_u0, curve_u1, curve_0w, curve_1w = self.curves\n        curves_copy = (\n            curve_u0.copy(),\n            curve_u1.copy(),\n            curve_0w.copy(),\n            curve_1w.copy(),\n        )\n        copy = CoonsPatch(curves_copy)\n        copy._is_normal_flipped = self._is_normal_flipped\n        return copy\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        for curve in self.curves:\n            curve.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        for curve in self.curves:\n            curve.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        for curve in self.curves:\n            curve.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/CoonsPatch/#pymesh.geo.surfaces.coons_patch.CoonsPatch.__init__","title":"__init__","text":"<pre><code>__init__(curves)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>curves</code> <code>list[Curve] | tuple[Curve]</code> <p>List or tuple with four Curve instances defining the surface boundary curves.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If curves is not of type list or tuple.</p> <code>ValueError</code> <p>If length of curves is not equal to four.</p> <code>TypeError</code> <p>If elements of curves are not of type Curve.</p> Source code in <code>pymesh/geo/surfaces/coons_patch.py</code> <pre><code>def __init__(self, curves: list[Curve] | tuple[Curve]):\n    \"\"\"Initialization method.\n\n    Args:\n        curves: List or tuple with four Curve instances\n            defining the surface boundary curves.\n\n    Raises:\n        TypeError: If curves is not of type list or tuple.\n        ValueError: If length of curves is not equal to four.\n        TypeError: If elements of curves are not of type Curve.\n    \"\"\"\n    self._all_surfaces.append(self)\n    self.curves = curves  # also sets self._flipped_curves\n</code></pre>"},{"location":"doc-pages/CosineDistribution/","title":"CosineDistribution","text":"<p>               Bases: <code>MeshDistribution</code></p> <p>Cosine path distribution class expression: fn(u) = cos[(u-1)*pi/2]</p> <p>For more information, see MeshDistribution.</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>class CosineDistribution(MeshDistribution):\n    \"\"\"Cosine path distribution class\n    expression: fn(u) = cos[(u-1)*pi/2]\n\n    For more information, see [MeshDistribution][pymesh.mesh.mesh_distributions.MeshDistribution].\n    \"\"\"\n\n    def __init__(self, flip_direction: bool = False):\n        super().__init__(flip_direction=flip_direction)\n\n    def copy(self) -&gt; Self:\n        return CosineDistribution(self.flip_direction)\n\n    def get_dist_fn(self):\n        flip = True if self.flip_direction else False  # breaks ref to self\n\n        def fn(u: int | float, flip_direction: bool = flip) -&gt; float:\n            u = self.validate_fn_input(u=u, flip_direction=flip_direction)\n            exp = math.cos((u - 1.0) * math.pi / 2)\n            return self.flip_exp(exp, flip_direction)\n\n        return fn\n</code></pre>"},{"location":"doc-pages/Curve/","title":"Curve","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class used which all curve classes inherit from.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>Point</code> <p>Curve starting point.</p> <code>end</code> <code>Point</code> <p>Curve ending point.</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>class Curve(ABC):\n    \"\"\"Abstract base class used which all curve classes inherit from.\n\n    Attributes:\n        start (Point): Curve starting point.\n        end (Point): Curve ending point.\n    \"\"\"\n\n    start = AsInstanceOf(Point)\n    \"\"\"Curve starting point.\"\"\"\n\n    end = AsInstanceOf(Point)\n    \"\"\"Curve ending point.\"\"\"\n\n    @abstractmethod\n    def copy(self) -&gt; Self:\n        \"\"\"Returns a recursive copy of curve instance.\"\"\"\n\n    @abstractmethod\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        \"\"\"Moves the curve a given relative position in space.\n\n        Args:\n            dx: Distance moved in the x-direction.\n            dy: Distance moved in the y-direction.\n            dz: Distance moved in the z-direction.\n\n        Returns:\n            (Curve): Curve with updated xyz coordinates.\n\n        Raises:\n            TypeError: If dx, dy or dz are not of type int or float.\n            ValueError: If dx, dy and dz are all zero.\n        \"\"\"\n\n    @abstractmethod\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        \"\"\"Rotates curve around an axis.\n\n        Implementation based on [WikiPedia](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n\n        Args:\n            angle: Angle in radians.\n                Poitive direction defined as counter-clockwise, based on the right-hand rule.\n            a: Axis vector x direction.\n            b: Axis vector y direction.\n            c: Axis vector z direction.\n            x0: Axis base x coordinate\n                Default is zero.\n            y0: Axis base y coordinate\n                Default is zero.\n            z0: Axis base z coordinate\n                Default is zero.\n\n        Returns:\n            (Curve): Rotated curve instance.\n\n        Raises:\n            TypeError: If input value are not of type int or float.\n        \"\"\"\n\n    @abstractmethod\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        \"\"\"Mirrors curve in a plane.\n\n        Plane is defined by a plane normal vector (a, b, c) and a point (x0, y0, z0) in the plane.\n        Implementation based on formulation by [Jean Marie](https://math.stackexchange.com/questions/3927881/reflection-over-planes-in-3d).\n\n        Args:\n            a: Plane normal vector x dimension.\n            b: Plane normal vector y dimension.\n            c: Plane normal vector z dimension.\n            x0: Plane normal vector base x coordinate\n                Default is origin of coordinate system.\n            y0: Plane normal vector base y coordinate\n                Default is origin of coordinate system.\n            z0: Plane normal vector base z coordinate\n                Default is origin of coordinate system.\n\n        Returns: Mirrored curve instance.\n\n        Raises:\n            TypeError: If input value are not of type int or float.\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def length(self) -&gt; float:\n        \"\"\"Returns the curve path length\"\"\"\n\n    @abstractmethod\n    def path(self, u: int | float, flip: bool = False) -&gt; NDArray3[np.float64]:\n        \"\"\"Curve path function that converts a normalized input u to a physical xyz point in space.\n\n        Args:\n            u: Normalized path parameter between 0 and 1,\n                where 0 and 1 represents the start and end locations, respectively.\n            flip: Bool specifying if path direction is flipped.\n                If True then u = (1 - u), i.e. the direction is flipped. Defaults\n                to False.\n\n        Returns:\n            (NDArray3): Numpy ndarray with shape (3,)\n\n        Raises:\n            TypeError: If u is not of type int or float.\n            ValueError: If u is not part of the number set [0 1].\n        \"\"\"\n\n    def get_path(self) -&gt; Callable[[int | float, bool], NDArray3[np.float64]]:\n        \"\"\"Returns curve path function\"\"\"\n        return self.path\n</code></pre>"},{"location":"doc-pages/Curve/#pymesh.geo.curves.curve.Curve.start","title":"start  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start = AsInstanceOf(Point)\n</code></pre> <p>Curve starting point.</p>"},{"location":"doc-pages/Curve/#pymesh.geo.curves.curve.Curve.end","title":"end  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end = AsInstanceOf(Point)\n</code></pre> <p>Curve ending point.</p>"},{"location":"doc-pages/Curve/#pymesh.geo.curves.curve.Curve.length","title":"length  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>length\n</code></pre> <p>Returns the curve path length</p>"},{"location":"doc-pages/Curve/#pymesh.geo.curves.curve.Curve.copy","title":"copy  <code>abstractmethod</code>","text":"<pre><code>copy()\n</code></pre> <p>Returns a recursive copy of curve instance.</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>@abstractmethod\ndef copy(self) -&gt; Self:\n    \"\"\"Returns a recursive copy of curve instance.\"\"\"\n</code></pre>"},{"location":"doc-pages/Curve/#pymesh.geo.curves.curve.Curve.move","title":"move  <code>abstractmethod</code>","text":"<pre><code>move(dx=0.0, dy=0.0, dz=0.0)\n</code></pre> <p>Moves the curve a given relative position in space.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>int | float</code> <p>Distance moved in the x-direction.</p> <code>0.0</code> <code>dy</code> <code>int | float</code> <p>Distance moved in the y-direction.</p> <code>0.0</code> <code>dz</code> <code>int | float</code> <p>Distance moved in the z-direction.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Curve</code> <p>Curve with updated xyz coordinates.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If dx, dy or dz are not of type int or float.</p> <code>ValueError</code> <p>If dx, dy and dz are all zero.</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>@abstractmethod\ndef move(\n    self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n) -&gt; Self:\n    \"\"\"Moves the curve a given relative position in space.\n\n    Args:\n        dx: Distance moved in the x-direction.\n        dy: Distance moved in the y-direction.\n        dz: Distance moved in the z-direction.\n\n    Returns:\n        (Curve): Curve with updated xyz coordinates.\n\n    Raises:\n        TypeError: If dx, dy or dz are not of type int or float.\n        ValueError: If dx, dy and dz are all zero.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/Curve/#pymesh.geo.curves.curve.Curve.rotate","title":"rotate  <code>abstractmethod</code>","text":"<pre><code>rotate(angle, a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Rotates curve around an axis.</p> <p>Implementation based on WikiPedia.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>int | float</code> <p>Angle in radians. Poitive direction defined as counter-clockwise, based on the right-hand rule.</p> required <code>a</code> <code>int | float</code> <p>Axis vector x direction.</p> required <code>b</code> <code>int | float</code> <p>Axis vector y direction.</p> required <code>c</code> <code>int | float</code> <p>Axis vector z direction.</p> required <code>x0</code> <code>int | float</code> <p>Axis base x coordinate Default is zero.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Axis base y coordinate Default is zero.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Axis base z coordinate Default is zero.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Curve</code> <p>Rotated curve instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input value are not of type int or float.</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>@abstractmethod\ndef rotate(\n    self,\n    angle: int | float,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; Self:\n    \"\"\"Rotates curve around an axis.\n\n    Implementation based on [WikiPedia](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n\n    Args:\n        angle: Angle in radians.\n            Poitive direction defined as counter-clockwise, based on the right-hand rule.\n        a: Axis vector x direction.\n        b: Axis vector y direction.\n        c: Axis vector z direction.\n        x0: Axis base x coordinate\n            Default is zero.\n        y0: Axis base y coordinate\n            Default is zero.\n        z0: Axis base z coordinate\n            Default is zero.\n\n    Returns:\n        (Curve): Rotated curve instance.\n\n    Raises:\n        TypeError: If input value are not of type int or float.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/Curve/#pymesh.geo.curves.curve.Curve.mirror","title":"mirror  <code>abstractmethod</code>","text":"<pre><code>mirror(a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Mirrors curve in a plane.</p> <p>Plane is defined by a plane normal vector (a, b, c) and a point (x0, y0, z0) in the plane. Implementation based on formulation by Jean Marie.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | float</code> <p>Plane normal vector x dimension.</p> required <code>b</code> <code>int | float</code> <p>Plane normal vector y dimension.</p> required <code>c</code> <code>int | float</code> <p>Plane normal vector z dimension.</p> required <code>x0</code> <code>int | float</code> <p>Plane normal vector base x coordinate Default is origin of coordinate system.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Plane normal vector base y coordinate Default is origin of coordinate system.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Plane normal vector base z coordinate Default is origin of coordinate system.</p> <code>0.0</code> <p>Returns: Mirrored curve instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input value are not of type int or float.</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>@abstractmethod\ndef mirror(\n    self,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; Self:\n    \"\"\"Mirrors curve in a plane.\n\n    Plane is defined by a plane normal vector (a, b, c) and a point (x0, y0, z0) in the plane.\n    Implementation based on formulation by [Jean Marie](https://math.stackexchange.com/questions/3927881/reflection-over-planes-in-3d).\n\n    Args:\n        a: Plane normal vector x dimension.\n        b: Plane normal vector y dimension.\n        c: Plane normal vector z dimension.\n        x0: Plane normal vector base x coordinate\n            Default is origin of coordinate system.\n        y0: Plane normal vector base y coordinate\n            Default is origin of coordinate system.\n        z0: Plane normal vector base z coordinate\n            Default is origin of coordinate system.\n\n    Returns: Mirrored curve instance.\n\n    Raises:\n        TypeError: If input value are not of type int or float.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/Curve/#pymesh.geo.curves.curve.Curve.path","title":"path  <code>abstractmethod</code>","text":"<pre><code>path(u, flip=False)\n</code></pre> <p>Curve path function that converts a normalized input u to a physical xyz point in space.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>int | float</code> <p>Normalized path parameter between 0 and 1, where 0 and 1 represents the start and end locations, respectively.</p> required <code>flip</code> <code>bool</code> <p>Bool specifying if path direction is flipped. If True then u = (1 - u), i.e. the direction is flipped. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>NDArray3</code> <p>Numpy ndarray with shape (3,)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If u is not of type int or float.</p> <code>ValueError</code> <p>If u is not part of the number set [0 1].</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>@abstractmethod\ndef path(self, u: int | float, flip: bool = False) -&gt; NDArray3[np.float64]:\n    \"\"\"Curve path function that converts a normalized input u to a physical xyz point in space.\n\n    Args:\n        u: Normalized path parameter between 0 and 1,\n            where 0 and 1 represents the start and end locations, respectively.\n        flip: Bool specifying if path direction is flipped.\n            If True then u = (1 - u), i.e. the direction is flipped. Defaults\n            to False.\n\n    Returns:\n        (NDArray3): Numpy ndarray with shape (3,)\n\n    Raises:\n        TypeError: If u is not of type int or float.\n        ValueError: If u is not part of the number set [0 1].\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/Curve/#pymesh.geo.curves.curve.Curve.get_path","title":"get_path","text":"<pre><code>get_path()\n</code></pre> <p>Returns curve path function</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>def get_path(self) -&gt; Callable[[int | float, bool], NDArray3[np.float64]]:\n    \"\"\"Returns curve path function\"\"\"\n    return self.path\n</code></pre>"},{"location":"doc-pages/ExponentialDistribution/","title":"ExponentialDistribution","text":"<p>               Bases: <code>MeshDistribution</code></p> <p>Exponential path distribution class expression: fn(u) = exp[ratio*u]</p> <p>For more information, see MeshDistribution.</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>class ExponentialDistribution(MeshDistribution):\n    \"\"\"Exponential path distribution class\n    expression: fn(u) = exp[ratio*u]\n\n    For more information, see [MeshDistribution][pymesh.mesh.mesh_distributions.MeshDistribution].\n    \"\"\"\n\n    ratio = AsNumber(return_type=float)\n\n    def __init__(self, ratio: int | float = 1.0, flip_direction: bool = False):\n        super().__init__(flip_direction=flip_direction)\n        self.ratio = ratio\n\n    def copy(self) -&gt; Self:\n        return ExponentialDistribution(self.ratio, self.flip_direction)\n\n    def get_dist_fn(self):\n        flip = True if self.flip_direction else False  # breaks ref to self\n\n        def fn(u: int | float, flip_direction: bool = flip) -&gt; float:\n            u = self.validate_fn_input(u=u, flip_direction=flip_direction)\n            exp = (math.exp(self.ratio * u) - 1.0) / (math.exp(self.ratio * 1.0) - 1.0)\n            return self.flip_exp(exp, flip_direction)\n\n        return fn\n</code></pre>"},{"location":"doc-pages/GDFWriter/","title":"GDFWriter","text":"<p>Writes surface panels to filename with the extension 'gdf'.</p> <p>For information regarding the file formatting, refer to Section 6.1 in the WAMIT Manual.</p> <p>Attributes:</p> Name Type Description <code>ulen</code> <code>float</code> <p>unit length</p> <code>grav</code> <code>float</code> <p>gravitational constant</p> <code>isx</code> <code>bool</code> <p>symmetry in x=0. If True, the x = 0 plane is a geometric plane of symmetry. If False, the x = 0 plane is not a geometric plane of symmetry.</p> <code>isy</code> <code>bool</code> <p>symmetry in y=0. If True, the y = 0 plane is a geometric plane of symmetry. If False, the y = 0 plane is not a geometric plane of symmetry.</p> <code>header</code> <code>str</code> <p>header line in output file</p> Source code in <code>pymesh/writers/gdf_writer.py</code> <pre><code>class GDFWriter:\n    \"\"\"Writes surface panels to filename with the extension 'gdf'.\n\n    For information regarding the file formatting, refer to Section 6.1\n    in the [WAMIT Manual](https://www.wamit.com/manual7.x/v75_manual.pdf).\n\n    Attributes:\n        ulen (float): unit length\n        grav (float): gravitational constant\n        isx (bool): symmetry in x=0.\n            If True, the x = 0 plane is a geometric plane of symmetry.\n            If False, the x = 0 plane is *not* a geometric plane of symmetry.\n        isy (bool): symmetry in y=0.\n            If True, the y = 0 plane is a geometric plane of symmetry.\n            If False, the y = 0 plane is *not* a geometric plane of symmetry.\n        header (str): header line in output file\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh: MeshGenerator,\n        ulen: float = 1.0,\n        grav: float = 9.816,\n        isx: bool = False,\n        isy: bool = False,\n        header: str = None,\n    ) -&gt; None:\n        self.panels = mesh.get_panels()\n        self.ulen = ulen\n        self.grav = grav\n        self.isx = isx\n        self.isy = isy\n        if header is None:\n            header = \"auto-generated using the pymesh package\"\n        self.header = header\n\n    @property\n    def header(self) -&gt; str:\n        return self._header\n\n    @header.setter\n    def header(self, value: str) -&gt; None:\n        if not isinstance(value, str):\n            raise TypeError(\"header must be of type 'str'\")\n        if len(value) &gt; 72:\n            raise ValueError(\"header text string is more than 72 characters\")\n        self._header = value\n\n    @property\n    def ulen(self) -&gt; float:\n        return self._ulen\n\n    @ulen.setter\n    def ulen(self, value: float) -&gt; None:\n        if not isinstance(value, float):\n            raise TypeError(\"ulen must be of type 'float'\")\n        if value &lt;= 0:\n            raise ValueError(\"ulen must be positive\")\n        self._ulen = value\n\n    @property\n    def grav(self) -&gt; float:\n        return self._grav\n\n    @grav.setter\n    def grav(self, value: float) -&gt; None:\n        if not isinstance(value, float):\n            raise TypeError(\"grav must be of type 'float'\")\n        if value &lt;= 0:\n            raise ValueError(\"grav must be positive\")\n        self._grav = value\n\n    @property\n    def isx(self) -&gt; bool:\n        return self._isx\n\n    @isx.setter\n    def isx(self, value: bool) -&gt; None:\n        if not isinstance(value, bool):\n            raise TypeError(\"isx must be of type 'bool'\")\n        self._isx = value\n\n    @property\n    def isy(self) -&gt; bool:\n        return self._isy\n\n    @isy.setter\n    def isy(self, value: bool) -&gt; None:\n        if not isinstance(value, bool):\n            raise TypeError(\"isy must be of type 'bool'\")\n        self._isy = value\n\n    def write(self, filename: Path):\n        \"\"\"Writes surface panels to file.\n\n        Args:\n            filename (Path): Filename path without extention.\n        \"\"\"\n        self.__validate_filename(filename)\n        with open(filename, \"w+\", encoding=\"utf-8\") as file:\n            file.write(f\"{self.header}\\n\")\n            file.write(f\"{self.ulen:f} {self.grav:f}\\n\")\n            file.write(f\"{self.isx:.0f} {self.isy:.0f}\\n\")\n            npan = len(self.panels)\n            file.write(f\"{npan:.0f}\\n\")\n            for panel in self.panels:\n                txt = \"\"\n                for i, coord in enumerate(panel):\n                    txt_space = \"\" if i == 0 else \" \"\n                    txt += f\"{txt_space}{coord:+.4e}\"\n                file.write(f\"{txt}\\n\")\n\n    def __validate_filename(self, filename: Path) -&gt; None:\n        if not isinstance(filename, Path):\n            raise TypeError(\"filename musth be of type 'Path'\")\n        if not self.__is_gdf(filename):\n            raise TypeError(\"filename must have the extension '.gdf'\")\n\n    def __is_gdf(self, filename) -&gt; bool:\n        _, extension = os.path.splitext(filename)\n        extension = extension.lower()\n        return extension == \".gdf\"\n</code></pre>"},{"location":"doc-pages/GDFWriter/#pymesh.writers.gdf_writer.GDFWriter.write","title":"write","text":"<pre><code>write(filename)\n</code></pre> <p>Writes surface panels to file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>Filename path without extention.</p> required Source code in <code>pymesh/writers/gdf_writer.py</code> <pre><code>def write(self, filename: Path):\n    \"\"\"Writes surface panels to file.\n\n    Args:\n        filename (Path): Filename path without extention.\n    \"\"\"\n    self.__validate_filename(filename)\n    with open(filename, \"w+\", encoding=\"utf-8\") as file:\n        file.write(f\"{self.header}\\n\")\n        file.write(f\"{self.ulen:f} {self.grav:f}\\n\")\n        file.write(f\"{self.isx:.0f} {self.isy:.0f}\\n\")\n        npan = len(self.panels)\n        file.write(f\"{npan:.0f}\\n\")\n        for panel in self.panels:\n            txt = \"\"\n            for i, coord in enumerate(panel):\n                txt_space = \"\" if i == 0 else \" \"\n                txt += f\"{txt_space}{coord:+.4e}\"\n            file.write(f\"{txt}\\n\")\n</code></pre>"},{"location":"doc-pages/Line/","title":"Line","text":"<p>               Bases: <code>Curve</code></p> <p>Creates a straight line object, generated from two points in space.</p> <p>For more information, see Curve documentation.</p> Source code in <code>pymesh/geo/curves/line.py</code> <pre><code>class Line(Curve):\n    \"\"\"Creates a straight line object, generated from two points in space.\n\n    For more information, see Curve documentation.\n    \"\"\"\n\n    def __init__(self, start: Point, end: Point):\n        \"\"\"Initialization method.\n\n        Args:\n            start (Point): Line start point\n            end (Point): Line end point\n\n        Raises:\n            ValueError: If start and end points are the same.\n        \"\"\"\n        self.start = start\n        self.end = end\n        if start == end:\n            raise ValueError(\"start and end points are the same\")\n\n    def __eq__(self, other):\n        return self.start == other.start and self.end == other.end\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __repr__(self):\n        return f\"{type(self).__name__}(start={self.start!r}, end={self.end!r})\"\n\n    @property\n    def length(self) -&gt; float:\n        return np.sqrt(np.sum((self.end - self.start) ** 2))\n\n    def path(self, u: int | float, flip: bool = False) -&gt; NDArray3[np.float64]:\n        u = validate_curve_path_parameters(u, flip)\n        return self.start.xyz + (self.end - self.start) * u\n\n    def copy(self) -&gt; Self:\n        return Line(self.start.copy(), self.end.copy())\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.start.move(dx, dy, dz)\n        self.end.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.start.rotate(angle, a, b, c, x0, y0, z0)\n        self.end.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.start.mirror(a, b, c, x0, y0, z0)\n        self.end.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/Line/#pymesh.geo.curves.line.Line.__init__","title":"__init__","text":"<pre><code>__init__(start, end)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Point</code> <p>Line start point</p> required <code>end</code> <code>Point</code> <p>Line end point</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If start and end points are the same.</p> Source code in <code>pymesh/geo/curves/line.py</code> <pre><code>def __init__(self, start: Point, end: Point):\n    \"\"\"Initialization method.\n\n    Args:\n        start (Point): Line start point\n        end (Point): Line end point\n\n    Raises:\n        ValueError: If start and end points are the same.\n    \"\"\"\n    self.start = start\n    self.end = end\n    if start == end:\n        raise ValueError(\"start and end points are the same\")\n</code></pre>"},{"location":"doc-pages/LinearDistribution/","title":"LinearDistribution","text":"<p>               Bases: <code>MeshDistribution</code></p> <p>Linear path distribution class expression: fn(u) = u</p> <p>For more information, see MeshDistribution.</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>class LinearDistribution(MeshDistribution):\n    \"\"\"Linear path distribution class\n    expression: fn(u) = u\n\n    For more information, see [MeshDistribution][pymesh.mesh.mesh_distributions.MeshDistribution].\n    \"\"\"\n\n    def __init__(self, flip_direction: bool = False):\n        super().__init__(flip_direction=flip_direction)\n\n    def copy(self) -&gt; Self:\n        return LinearDistribution(self.flip_direction)\n\n    def get_dist_fn(self):\n        flip = True if self.flip_direction else False  # breaks ref to self\n\n        def fn(u: int | float, flip_direction: bool = flip) -&gt; float:\n            u = self.validate_fn_input(u=u, flip_direction=flip_direction)\n            exp = u\n            return self.flip_exp(exp, flip_direction)\n\n        return fn\n</code></pre>"},{"location":"doc-pages/MeshDistribution/","title":"MeshDistribution","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract mesh distribution base class.</p> See also <ul> <li>LinearDistribution</li> <li>CosineDistribution</li> <li>PowerDistribution</li> <li>ExponentialDistribution</li> </ul> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>class MeshDistribution(ABC):\n    \"\"\"Abstract mesh distribution base class.\n\n    See also:\n        - [LinearDistribution][pymesh.mesh.mesh_distributions.LinearDistribution]\n        - [CosineDistribution][pymesh.mesh.mesh_distributions.CosineDistribution]\n        - [PowerDistribution][pymesh.mesh.mesh_distributions.PowerDistribution]\n        - [ExponentialDistribution][pymesh.mesh.mesh_distributions.ExponentialDistribution]\n    \"\"\"\n\n    def __init__(self, flip_direction: bool = False):\n        self.flip_direction = flip_direction\n\n    def __repr__(self) -&gt; str:\n        return self.__class__.__name__\n\n    @property\n    def flip_direction(self) -&gt; bool:\n        return self._flip_direction\n\n    @flip_direction.setter\n    def flip_direction(self, value) -&gt; None:\n        if not isinstance(value, bool):\n            raise TypeError(\"flip_direction must be of type 'bool'\")\n        self._flip_direction = value\n\n    @abstractmethod\n    def copy(self) -&gt; Self:\n        \"\"\"Returns a copy of self\"\"\"\n\n    @abstractmethod\n    def get_dist_fn(self, flip_direction: bool):\n        \"\"\"Returns distribution function which takes a single float from 0 to 1\n        and returns a float between 0 and 1 according to the distribution type.\n        \"\"\"\n\n    @staticmethod\n    def flip_exp(exp, flip_direction: bool):\n        \"\"\"Flips 'exp' to '1.0 - exp' if flip_direction is True\"\"\"\n        if not flip_direction:\n            return exp\n        return 1.0 - exp\n\n    @staticmethod\n    def validate_fn_input(u: int | float, flip_direction: bool) -&gt; float:\n        \"\"\"Validates type of inputs u and flip_direction\"\"\"\n        if not isinstance(flip_direction, bool):\n            raise TypeError(\"flip_direction mus be of type 'bool'\")\n        if not isinstance(u, (int, float)):\n            raise TypeError(\"u must be of type 'int' or 'float'\")\n        if isinstance(u, int):\n            u = float(u)\n        if u &lt; 0 or u &gt; 1:\n            raise ValueError(\"u must be a value between 0 and 1\")\n        if flip_direction:\n            u = 1.0 - u\n        return u\n</code></pre>"},{"location":"doc-pages/MeshDistribution/#pymesh.mesh.mesh_distributions.MeshDistribution.copy","title":"copy  <code>abstractmethod</code>","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of self</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>@abstractmethod\ndef copy(self) -&gt; Self:\n    \"\"\"Returns a copy of self\"\"\"\n</code></pre>"},{"location":"doc-pages/MeshDistribution/#pymesh.mesh.mesh_distributions.MeshDistribution.get_dist_fn","title":"get_dist_fn  <code>abstractmethod</code>","text":"<pre><code>get_dist_fn(flip_direction)\n</code></pre> <p>Returns distribution function which takes a single float from 0 to 1 and returns a float between 0 and 1 according to the distribution type.</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>@abstractmethod\ndef get_dist_fn(self, flip_direction: bool):\n    \"\"\"Returns distribution function which takes a single float from 0 to 1\n    and returns a float between 0 and 1 according to the distribution type.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/MeshDistribution/#pymesh.mesh.mesh_distributions.MeshDistribution.flip_exp","title":"flip_exp  <code>staticmethod</code>","text":"<pre><code>flip_exp(exp, flip_direction)\n</code></pre> <p>Flips 'exp' to '1.0 - exp' if flip_direction is True</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>@staticmethod\ndef flip_exp(exp, flip_direction: bool):\n    \"\"\"Flips 'exp' to '1.0 - exp' if flip_direction is True\"\"\"\n    if not flip_direction:\n        return exp\n    return 1.0 - exp\n</code></pre>"},{"location":"doc-pages/MeshDistribution/#pymesh.mesh.mesh_distributions.MeshDistribution.validate_fn_input","title":"validate_fn_input  <code>staticmethod</code>","text":"<pre><code>validate_fn_input(u, flip_direction)\n</code></pre> <p>Validates type of inputs u and flip_direction</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>@staticmethod\ndef validate_fn_input(u: int | float, flip_direction: bool) -&gt; float:\n    \"\"\"Validates type of inputs u and flip_direction\"\"\"\n    if not isinstance(flip_direction, bool):\n        raise TypeError(\"flip_direction mus be of type 'bool'\")\n    if not isinstance(u, (int, float)):\n        raise TypeError(\"u must be of type 'int' or 'float'\")\n    if isinstance(u, int):\n        u = float(u)\n    if u &lt; 0 or u &gt; 1:\n        raise ValueError(\"u must be a value between 0 and 1\")\n    if flip_direction:\n        u = 1.0 - u\n    return u\n</code></pre>"},{"location":"doc-pages/MeshGenerator/","title":"MeshGenerator","text":"<p>Mesh generator class.</p> <p>Attributes:</p> Name Type Description <code>surfaces</code> <code>list[dict]</code> <p>List of surface dictionaries with mesh information.</p> Source code in <code>pymesh/mesh/mesh_generator.py</code> <pre><code>class MeshGenerator:\n    \"\"\"Mesh generator class.\n\n    Attributes:\n        surfaces: List of surface dictionaries with mesh information.\n    \"\"\"\n\n    surfaces: list[dict] = []\n    \"\"\"List of surface dictionaries with mesh information.\n\n    Each surface dictionary follows the structure:\n\n    .. code-block:: python3\n        surface = {\n            \"path\": Callable[[float], NDArray3],\n            \"flipped_normal\": bool,\n            \"num_points\": tuple[int],\n            \"distributions\": tuple[MeshDistribution],\n        }\n\n    Note:\n        Above code block works in Visual Studio Code.\n    \"\"\"\n\n    def add_surface(\n        self,\n        surface: Surface,\n        density_u: int | float = 0.2,\n        density_w: int | float = 0.2,\n        distribution_u: MeshDistribution = LinearDistribution(),\n        distribution_w: MeshDistribution = LinearDistribution(),\n    ) -&gt; None:\n        \"\"\"Adds a surface to the mesh.\n\n        Args:\n            surface: Surface object to be added.\n            density_u: Panel density along the u dimension.\n                Integer values represent the number of panels,\n                while float values represent panel size.\n            density_w: Panel density along the w dimension.\n                Integer values represent the number of panels,\n                while float values represent panel size.\n            distribution_u: Distribution type along the u dimension.\n            distribution_w: Distribution type along the w dimension.\n\n        Examples:\n            Initialize a mesh and add a surface with two panels (linearly distributed\n            by default) along the u dimension and a panel length of 0.1 units along\n            the w dimension. These panels are distributed exponentially.\n\n            &gt;&gt;&gt; surface = PlaneSurface(Point(0, 0, 0), Point(1, 0, 0), Point(0, 1, 0))\n            &gt;&gt;&gt; dist_exp = ExponentialDistribution()\n            &gt;&gt;&gt; mesh = MeshGenerator()\n            &gt;&gt;&gt; mesh.add_surface(surface, density_u=2, density_w=0.1, distribution_w=dist_exp)\n\n            The user is referred to [pymesh.mesh.mesh_distributions][] for more\n            information on distribution_u and distribution_w options.\n\n        Note:\n            Above example code block style works with MkDocs, but does not look nice\n            in Visual Studio Code.\n        \"\"\"\n        length_u, length_w = surface.get_max_lengths()\n        num_points_u = self.get_num_points(length_u, density_u)\n        num_points_w = self.get_num_points(length_w, density_w)\n        data = {\n            \"path\": surface.get_path(),\n            \"flipped_normal\": surface.is_normal_flipped,\n            \"num_points\": (num_points_u, num_points_w),\n            \"distributions\": (distribution_u, distribution_w),\n        }\n        self.surfaces.append(data)\n\n    @staticmethod\n    def get_num_points(length: float, density: int | float) -&gt; int:\n        \"\"\"Returns number of points along a dimension.\n\n        Args:\n            length: Lagest length of relevant surface boundary curves.\n            density: Panel density along the dimension.\n                Integer values represent the number of panels,\n                while float values represent panel size.\n\n        Returns:\n            num_points: Nummber of points needed along surface dimension.\n        \"\"\"\n        num_points = density + 1\n        if isinstance(density, float):\n            num_points = int(np.ceil(length / density) + 1)\n        return num_points\n\n    @staticmethod\n    def _generate_mesh_points(mesh) -&gt; NDArray3xNxN[np.float64]:\n        \"\"\"Generates mesh points\"\"\"\n        path = mesh[\"path\"]\n        num_points_u, num_points_w = mesh[\"num_points\"]\n        distribution_u, distribution_w = mesh[\"distributions\"]\n        ufn = distribution_u.get_dist_fn()\n        wfn = distribution_w.get_dist_fn()\n        mp = np.zeros((3, num_points_u, num_points_w))\n        for i, u in enumerate(np.linspace(0, 1, num=num_points_u, endpoint=True)):\n            for j, w in enumerate(np.linspace(0, 1, num=num_points_w, endpoint=True)):\n                mp[:, i, j] = path(ufn(u), wfn(w))\n        return mp\n\n    @staticmethod\n    def _generate_panels(\n        mesh_points: NDArray3xNxN[np.float64], flipped_normal: bool\n    ) -&gt; list[list[float]]:\n        \"\"\"Returns list of quadrilateral panels.\n\n        Each panel is defined as a list of 12 floating numbers,\n        representing the xyz coordinates of the four panel vertices:\n        panel = [x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3]\n        \"\"\"\n        panels = []\n        mp = mesh_points\n        for j in range(0, mp.shape[2] - 1):\n            for i in range(0, mp.shape[1] - 1):\n                xyz1 = mp[:, i, j]\n                xyz2 = mp[:, i + 1, j]\n                xyz3 = mp[:, i + 1, j + 1]\n                xyz4 = mp[:, i, j + 1]\n                if flipped_normal:\n                    xyz1, xyz2, xyz3, xyz4 = xyz4, xyz3, xyz2, xyz1\n                panels.append(\n                    [\n                        xyz1[0],\n                        xyz1[1],\n                        xyz1[2],\n                        xyz2[0],\n                        xyz2[1],\n                        xyz2[2],\n                        xyz3[0],\n                        xyz3[1],\n                        xyz3[2],\n                        xyz4[0],\n                        xyz4[1],\n                        xyz4[2],\n                    ]\n                )\n        return panels\n\n    def get_panels(self) -&gt; list[list[float]]:\n        \"\"\"Generates and returns panels for each item in the surfaces attribute list.\n\n        Returns:\n            panels: List of quadrilateral panels.\n                Each panel is defined as a list of 12 floating numbers,\n                representing the xyz coordinates of the four panel vertices:\n                panel = [x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3].\n        \"\"\"\n        panels = []\n        for data in self.surfaces:\n            mesh_points = self._generate_mesh_points(data)\n            surface_panels = self._generate_panels(mesh_points, data[\"flipped_normal\"])\n            panels += surface_panels\n        return panels\n</code></pre>"},{"location":"doc-pages/MeshGenerator/#pymesh.mesh.mesh_generator.MeshGenerator.surfaces","title":"surfaces  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>surfaces = []\n</code></pre> <p>List of surface dictionaries with mesh information.</p> <p>Each surface dictionary follows the structure:</p> <p>.. code-block:: python3     surface = {         \"path\": Callable[[float], NDArray3],         \"flipped_normal\": bool,         \"num_points\": tuple[int],         \"distributions\": tuple[MeshDistribution],     }</p> Note <p>Above code block works in Visual Studio Code.</p>"},{"location":"doc-pages/MeshGenerator/#pymesh.mesh.mesh_generator.MeshGenerator.add_surface","title":"add_surface","text":"<pre><code>add_surface(surface, density_u=0.2, density_w=0.2, distribution_u=LinearDistribution(), distribution_w=LinearDistribution())\n</code></pre> <p>Adds a surface to the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>surface</code> <code>Surface</code> <p>Surface object to be added.</p> required <code>density_u</code> <code>int | float</code> <p>Panel density along the u dimension. Integer values represent the number of panels, while float values represent panel size.</p> <code>0.2</code> <code>density_w</code> <code>int | float</code> <p>Panel density along the w dimension. Integer values represent the number of panels, while float values represent panel size.</p> <code>0.2</code> <code>distribution_u</code> <code>MeshDistribution</code> <p>Distribution type along the u dimension.</p> <code>LinearDistribution()</code> <code>distribution_w</code> <code>MeshDistribution</code> <p>Distribution type along the w dimension.</p> <code>LinearDistribution()</code> <p>Examples:</p> <p>Initialize a mesh and add a surface with two panels (linearly distributed by default) along the u dimension and a panel length of 0.1 units along the w dimension. These panels are distributed exponentially.</p> <pre><code>&gt;&gt;&gt; surface = PlaneSurface(Point(0, 0, 0), Point(1, 0, 0), Point(0, 1, 0))\n&gt;&gt;&gt; dist_exp = ExponentialDistribution()\n&gt;&gt;&gt; mesh = MeshGenerator()\n&gt;&gt;&gt; mesh.add_surface(surface, density_u=2, density_w=0.1, distribution_w=dist_exp)\n</code></pre> <p>The user is referred to pymesh.mesh.mesh_distributions for more information on distribution_u and distribution_w options.</p> Note <p>Above example code block style works with MkDocs, but does not look nice in Visual Studio Code.</p> Source code in <code>pymesh/mesh/mesh_generator.py</code> <pre><code>def add_surface(\n    self,\n    surface: Surface,\n    density_u: int | float = 0.2,\n    density_w: int | float = 0.2,\n    distribution_u: MeshDistribution = LinearDistribution(),\n    distribution_w: MeshDistribution = LinearDistribution(),\n) -&gt; None:\n    \"\"\"Adds a surface to the mesh.\n\n    Args:\n        surface: Surface object to be added.\n        density_u: Panel density along the u dimension.\n            Integer values represent the number of panels,\n            while float values represent panel size.\n        density_w: Panel density along the w dimension.\n            Integer values represent the number of panels,\n            while float values represent panel size.\n        distribution_u: Distribution type along the u dimension.\n        distribution_w: Distribution type along the w dimension.\n\n    Examples:\n        Initialize a mesh and add a surface with two panels (linearly distributed\n        by default) along the u dimension and a panel length of 0.1 units along\n        the w dimension. These panels are distributed exponentially.\n\n        &gt;&gt;&gt; surface = PlaneSurface(Point(0, 0, 0), Point(1, 0, 0), Point(0, 1, 0))\n        &gt;&gt;&gt; dist_exp = ExponentialDistribution()\n        &gt;&gt;&gt; mesh = MeshGenerator()\n        &gt;&gt;&gt; mesh.add_surface(surface, density_u=2, density_w=0.1, distribution_w=dist_exp)\n\n        The user is referred to [pymesh.mesh.mesh_distributions][] for more\n        information on distribution_u and distribution_w options.\n\n    Note:\n        Above example code block style works with MkDocs, but does not look nice\n        in Visual Studio Code.\n    \"\"\"\n    length_u, length_w = surface.get_max_lengths()\n    num_points_u = self.get_num_points(length_u, density_u)\n    num_points_w = self.get_num_points(length_w, density_w)\n    data = {\n        \"path\": surface.get_path(),\n        \"flipped_normal\": surface.is_normal_flipped,\n        \"num_points\": (num_points_u, num_points_w),\n        \"distributions\": (distribution_u, distribution_w),\n    }\n    self.surfaces.append(data)\n</code></pre>"},{"location":"doc-pages/MeshGenerator/#pymesh.mesh.mesh_generator.MeshGenerator.get_num_points","title":"get_num_points  <code>staticmethod</code>","text":"<pre><code>get_num_points(length, density)\n</code></pre> <p>Returns number of points along a dimension.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>float</code> <p>Lagest length of relevant surface boundary curves.</p> required <code>density</code> <code>int | float</code> <p>Panel density along the dimension. Integer values represent the number of panels, while float values represent panel size.</p> required <p>Returns:</p> Name Type Description <code>num_points</code> <code>int</code> <p>Nummber of points needed along surface dimension.</p> Source code in <code>pymesh/mesh/mesh_generator.py</code> <pre><code>@staticmethod\ndef get_num_points(length: float, density: int | float) -&gt; int:\n    \"\"\"Returns number of points along a dimension.\n\n    Args:\n        length: Lagest length of relevant surface boundary curves.\n        density: Panel density along the dimension.\n            Integer values represent the number of panels,\n            while float values represent panel size.\n\n    Returns:\n        num_points: Nummber of points needed along surface dimension.\n    \"\"\"\n    num_points = density + 1\n    if isinstance(density, float):\n        num_points = int(np.ceil(length / density) + 1)\n    return num_points\n</code></pre>"},{"location":"doc-pages/MeshGenerator/#pymesh.mesh.mesh_generator.MeshGenerator.get_panels","title":"get_panels","text":"<pre><code>get_panels()\n</code></pre> <p>Generates and returns panels for each item in the surfaces attribute list.</p> <p>Returns:</p> Name Type Description <code>panels</code> <code>list[list[float]]</code> <p>List of quadrilateral panels. Each panel is defined as a list of 12 floating numbers, representing the xyz coordinates of the four panel vertices: panel = [x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3].</p> Source code in <code>pymesh/mesh/mesh_generator.py</code> <pre><code>def get_panels(self) -&gt; list[list[float]]:\n    \"\"\"Generates and returns panels for each item in the surfaces attribute list.\n\n    Returns:\n        panels: List of quadrilateral panels.\n            Each panel is defined as a list of 12 floating numbers,\n            representing the xyz coordinates of the four panel vertices:\n            panel = [x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3].\n    \"\"\"\n    panels = []\n    for data in self.surfaces:\n        mesh_points = self._generate_mesh_points(data)\n        surface_panels = self._generate_panels(mesh_points, data[\"flipped_normal\"])\n        panels += surface_panels\n    return panels\n</code></pre>"},{"location":"doc-pages/MeshViewer/","title":"MeshViewer","text":"<p>Plots surface panels and normals using matplotlib with seaborn-v0_8 style</p> Source code in <code>pymesh/mesh/mesh_viewer.py</code> <pre><code>class MeshViewer:\n    \"\"\"Plots surface panels and normals using matplotlib with seaborn-v0_8 style\"\"\"\n\n    def __init__(self, mesh: MeshGenerator) -&gt; None:\n        self.panels = mesh.get_panels()\n        self.include_vertex_annotation = False\n        self.facecolor = \"#0072BD\"\n        self.edgecolor = \"black\"\n        self.linewidth = 0.5\n        self.alpha = 0.8\n        self.include_normals = True\n        self.normallength = 0.2\n        self.normalcolor = \"grey\"\n        self.xyzlim = np.array([1, 1, 1])\n        plt.close(\"all\")\n        mpl_style.use(\"seaborn-v0_8\")\n        fig = plt.figure()\n        fig.patch.set_facecolor(\"#EAEAF2\")\n        ax = fig.add_subplot(projection=\"3d\")\n        ax.set_xlabel(\"X axis\")\n        ax.set_ylabel(\"Y axis\")\n        ax.set_zlabel(\"Z axis\")\n        self._ax = ax\n\n    @property\n    def normallength(self) -&gt; float | None:\n        return self._normallength\n\n    @normallength.setter\n    def normallength(self, val) -&gt; None:\n        if not isinstance(val, (int, float)):\n            if not val is None:\n                raise TypeError(f\"Expected {val!r} to be int or float\")\n        if isinstance(val, int):\n            val = float(val)\n        self._normallength = val\n\n    @property\n    def ax(self):\n        return self._ax\n\n    @property\n    def xyzlim(self) -&gt; NDArray3:\n        return self._xyzlim\n\n    @xyzlim.setter\n    def xyzlim(self, value: NDArray3):\n        if not isinstance(value, np.ndarray):\n            raise TypeError(\"xyzlim must be of type 'ndarray'\")\n        if not value.shape == (3,):\n            raise TypeError(\"xyzlim must have shape (3,)\")\n        self._xyzlim = np.ceil(value)\n\n    def _plot_panels(self) -&gt; None:\n        for panel in self.panels:\n            xyz = np.array([panel[0:3], panel[3:6], panel[6:9], panel[9:12]])\n            self.__update_axis_limits(xyz)\n            if self.include_vertex_annotation:\n                self.ax.scatter(xyz[:, 0], xyz[:, 1], xyz[:, 2], color=\"blue\")\n                for i in range(0, xyz.shape[0]):\n                    self.ax.text(xyz[i, 0], xyz[i, 1], xyz[i, 2], f\"{i+1}\", color=\"k\")\n            if self.include_normals:\n                self._plot_normals(panel, colors=self.normalcolor)\n            verts = [list(zip(panel[0::3], panel[1::3], panel[2::3]))]\n            self.ax.add_collection3d(\n                Poly3DCollection(\n                    verts,\n                    facecolors=self.facecolor,\n                    linewidths=self.linewidth,\n                    edgecolors=self.edgecolor,\n                    alpha=self.alpha,\n                )\n            )\n\n    def __update_axis_limits(self, xyz):\n        x = np.max(np.abs(xyz[:, 0]))\n        y = np.max(np.abs(xyz[:, 1]))\n        z = np.max(np.abs(xyz[:, 2]))\n        xyzlim = np.max([self.xyzlim, np.array([x, y, z])], axis=0)\n        self.xyzlim = xyzlim\n\n    def _plot_normals(self, panel: list, colors: str) -&gt; None:\n        panel = np.array(panel)\n        xyz1, xyz2, xyz3, xyz4 = panel[0:3], panel[3:6], panel[6:9], panel[9:12]\n        point = np.average([xyz1, xyz2, xyz3, xyz4], axis=0)\n        cross_product = np.cross(xyz2 - xyz1, xyz4 - xyz1)\n        x, y, z = point[0], point[1], point[2]\n        u, v, w = cross_product[0], cross_product[1], cross_product[2]\n        self.ax.quiver(\n            x,\n            y,\n            z,\n            u,\n            v,\n            w,\n            length=self.normallength,\n            normalize=True,\n            colors=colors,\n        )\n\n    def _set_axis_limits(self) -&gt; None:\n        \"\"\"Sets axis limits according to xyzlim if include_normal is False.\n        Otherwise, uses the ax.axis(\"image\") algortihm.\n\n        This is done to make sure panels without normals are shown correctly.\n        However, ax.axis(\"image\") screws up with .normal_length visually.\n        \"\"\"\n        xlim, ylim, zlim = self.xyzlim\n        self.ax.set(xlim=(-np.ceil(xlim), np.ceil(xlim)))\n        self.ax.set(ylim=(-np.ceil(ylim), np.ceil(ylim)))\n        self.ax.set(zlim=(-np.ceil(zlim), np.ceil(zlim)))\n        if self.include_normals:\n            self.ax.axis(\"image\")\n\n    def show(self) -&gt; None:\n        self._plot_panels()\n        self._set_axis_limits()\n        plt.show()\n</code></pre>"},{"location":"doc-pages/PlaneSurface/","title":"PlaneSurface","text":"<p>               Bases: <code>Surface</code></p> <p>Creates a plane surface based on three points in space.</p> <p>The plane is drawn from the vectors |point1 - point0| and |point2 - point0|, where point0 is a shared point between the two vectors.</p> <p>Attributes:</p> Name Type Description <code>point0</code> <code>Point</code> <p>Shared point between two plane defining vectors.</p> <code>point1</code> <code>Point</code> <p>Point defining the |point1-point0| vector.</p> <code>point2</code> <code>Point</code> <p>Point defining the |point2-point0| vector.</p> Source code in <code>pymesh/geo/surfaces/plane_surface.py</code> <pre><code>class PlaneSurface(Surface):\n    \"\"\"Creates a plane surface based on three points in space.\n\n    The plane is drawn from the vectors |point1 - point0| and\n    |point2 - point0|, where point0 is a shared point between\n    the two vectors.\n\n    Attributes:\n        point0 (Point): Shared point between two plane defining vectors.\n        point1 (Point): Point defining the |point1-point0| vector.\n        point2 (Point): Point defining the |point2-point0| vector.\n    \"\"\"\n\n    point0 = AsInstanceOf(Point)\n    point1 = AsInstanceOf(Point)\n    point2 = AsInstanceOf(Point)\n\n    def __init__(self, point0: Point, point1: Point, point2: Point):\n        \"\"\"Initialiation method.\n\n        Args:\n            point0: Shared point between two plane defining vectors.\n            point1: Point defining the |point1-point0| vector.\n            point2: Point defining the |point2-point0| vector.\n\n        Raises:\n            TypeError: If point0, point1 or point2 are not of type Point.\n        \"\"\"\n        self._all_surfaces.append(self)\n        self.point0 = point0\n        self.point1 = point1\n        self.point2 = point2\n\n    def __eq__(self, other):\n        return (\n            self.point0 == other.point0\n            and self.point1 == other.point1\n            and self.point2 == other.point2\n        )\n\n    def __repr__(self):\n        return (\n            f\"{type(self).__name__}(point0={self.point0!r},\"\n            f\"point1={self.point1!r}, point2={self.point2!r})\"\n        )\n\n    def path(\n        self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n    ) -&gt; NDArray3[np.float64]:\n        # ! find a way to add np.ndarray to Point using __add__\n        u, w = validate_surface_path_parameters(u, w, uflip, wflip)\n        xyz0 = self.point0.xyz\n        u_point = (self.point1 - self.point0) * u\n        w_point = (self.point2 - self.point0) * w\n        return xyz0 + u_point + w_point\n\n    def get_max_lengths(self) -&gt; tuple[float]:\n        length_u = float(np.sqrt(np.sum((self.point1 - self.point0) ** 2)))\n        length_w = float(np.sqrt(np.sum((self.point2 - self.point0) ** 2)))\n        return length_u, length_w\n\n    def copy(self) -&gt; Self:\n        copy = PlaneSurface(self.point0.copy(), self.point1.copy(), self.point2.copy())\n        copy._is_normal_flipped = self._is_normal_flipped\n        return copy\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.point0.move(dx, dy, dz)\n        self.point1.move(dx, dy, dz)\n        self.point2.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.point0.rotate(angle, a, b, c, x0, y0, z0)\n        self.point1.rotate(angle, a, b, c, x0, y0, z0)\n        self.point2.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.point0.mirror(a, b, c, x0, y0, z0)\n        self.point1.mirror(a, b, c, x0, y0, z0)\n        self.point2.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/PlaneSurface/#pymesh.geo.surfaces.plane_surface.PlaneSurface.__init__","title":"__init__","text":"<pre><code>__init__(point0, point1, point2)\n</code></pre> <p>Initialiation method.</p> <p>Parameters:</p> Name Type Description Default <code>point0</code> <code>Point</code> <p>Shared point between two plane defining vectors.</p> required <code>point1</code> <code>Point</code> <p>Point defining the |point1-point0| vector.</p> required <code>point2</code> <code>Point</code> <p>Point defining the |point2-point0| vector.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If point0, point1 or point2 are not of type Point.</p> Source code in <code>pymesh/geo/surfaces/plane_surface.py</code> <pre><code>def __init__(self, point0: Point, point1: Point, point2: Point):\n    \"\"\"Initialiation method.\n\n    Args:\n        point0: Shared point between two plane defining vectors.\n        point1: Point defining the |point1-point0| vector.\n        point2: Point defining the |point2-point0| vector.\n\n    Raises:\n        TypeError: If point0, point1 or point2 are not of type Point.\n    \"\"\"\n    self._all_surfaces.append(self)\n    self.point0 = point0\n    self.point1 = point1\n    self.point2 = point2\n</code></pre>"},{"location":"doc-pages/Point/","title":"Point","text":"<p>Point class with xyz coordinates in three-dimensional space.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>int | float</code> <p>Point x coordinate.</p> <code>y</code> <code>int | float</code> <p>Point y coordinate.</p> <code>z</code> <code>int | float</code> <p>Point z coordinate.</p> <code>xyz</code> <code>NDArray3[float]</code> <p>Numpy ndarray with x, y and z values. The numpy ndarray has shape (3,) with x at index 0, y at index 1 and z at index 2.</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>class Point:\n    \"\"\"Point class with xyz coordinates in three-dimensional space.\n\n    Attributes:\n        x (int | float): Point x coordinate.\n        y (int | float): Point y coordinate.\n        z (int | float): Point z coordinate.\n        xyz (NDArray3[float]): Numpy ndarray with x, y and z values.\n            The numpy ndarray has shape (3,) with x at index 0, y at\n            index 1 and z at index 2.\n    \"\"\"\n\n    x = AsNumber(return_type=float)\n    y = AsNumber(return_type=float)\n    z = AsNumber(return_type=float)\n\n    def __init__(self, x: int | float, y: int | float, z: int | float) -&gt; None:\n        \"\"\"Initialization method.\n\n        Args:\n            x: Point x coordinate.\n            y: Point y coordinate.\n            z: Point z coordinate.\n        \"\"\"\n        self.x, self.y, self.z = x, y, z\n\n    @property\n    def xyz(self) -&gt; NDArray3[np.float64]:\n        return np.array([self.x, self.y, self.z])\n\n    def __eq__(self, other) -&gt; bool:\n        DECIMALS = 10\n        return np.all(\n            np.round(self.xyz, decimals=DECIMALS)\n            == np.round(other.xyz, decimals=DECIMALS)\n        )\n\n    def __ne__(self, other: object) -&gt; bool:\n        return not self.__eq__(other)\n\n    def __add__(self, other):\n        return self.xyz + other.xyz\n\n    def __sub__(self, other):\n        return self.xyz - other.xyz\n\n    def __repr__(self):\n        return f\"{type(self).__name__}(x={self.x:.2f}, y={self.y:.2f}, z={self.z:.2f})\"\n\n    def copy(self) -&gt; Self:\n        \"\"\"Returns a copy of point instance\"\"\"\n        return Point(self.x, self.y, self.z)\n\n    def move(self, dx: int | float, dy: int | float, dz: int | float) -&gt; Self:\n        \"\"\"Moves the point coordinates in space.\n\n        Args:\n            dx: Distance moved in the x-direction.\n            dy: Distance moved in the y-direction.\n            dz: Distance moved in the z-direction.\n\n        Returns:\n            (Point): Point with updated xyz coordinates.\n        \"\"\"\n        for val in (dx, dy, dz):\n            if not isinstance(val, (int, float)):\n                raise TypeError(f\"Expected {val!r} to be an int or float\")\n        self.x += float(dx)\n        self.y += float(dy)\n        self.z += float(dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        \"\"\"Rotates point around an axis.\n\n        Parameters are passed to [pymesh.utils.rotate_point_xyz][].\n        \"\"\"\n        self.x, self.y, self.z = rotate_point_xyz(\n            self.x, self.y, self.z, angle, a, b, c, x0, y0, z0\n        )\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        \"\"\"Mirrors point in a plane.\n\n        Parameters are passed to [pymesh.utils.mirror_point_xyz][].\n        \"\"\"\n        self.x, self.y, self.z = mirror_point_xyz(\n            self.x, self.y, self.z, a, b, c, x0, y0, z0\n        )\n        return self\n\n    def get_distance_to(self, point: Self) -&gt; float:\n        \"\"\"Returns the shortest distance between point instance and another point\n\n        Args:\n            point: Other point from which the distance is calculated.\n\n        Returns:\n            (float): Direct distance between this and other point.\n\n        Raises:\n            TypeError: If point is not of type Self.\n        \"\"\"\n        if not isinstance(point, Point):\n            raise TypeError(f\"point must be of type '{Point.__name__}'.\")\n        dx = self.x - point.x\n        dy = self.y - point.y\n        dz = self.z - point.z\n        return math.sqrt(dx**2 + dy**2 + dz**2)\n\n    def create_relative_point(\n        self, dx: int | float = 0, dy: int | float = 0, dz: int | float = 0\n    ) -&gt; Self:\n        \"\"\"Creates a new point using relative positional arguments.\n\n        Args:\n            dx: Relative x coordinate.\n            dy: Relative y coordinate.\n            dz: Relative z coordinate.\n\n        Returns:\n            (Point): New point based on relative coordinates.\n\n        Raises:\n            TypeError: If dx, dy or dz are not of type int or float.\n            ValueError: If both dx, dy and dz are equal to zero.\n        \"\"\"\n        for value in (dx, dy, dz):\n            if not isinstance(value, (int, float)):\n                raise TypeError(\"Relative position must be of type 'float' or 'int'\")\n        if (dx == 0.0) and (dy == 0.0) and (dz == 0.0):\n            raise ValueError(\"A non-zero relative position must be given\")\n        x = self.x + float(dx)\n        y = self.y + float(dy)\n        z = self.z + float(dz)\n        return Point(x, y, z)\n</code></pre>"},{"location":"doc-pages/Point/#pymesh.geo.point.Point.__init__","title":"__init__","text":"<pre><code>__init__(x, y, z)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int | float</code> <p>Point x coordinate.</p> required <code>y</code> <code>int | float</code> <p>Point y coordinate.</p> required <code>z</code> <code>int | float</code> <p>Point z coordinate.</p> required Source code in <code>pymesh/geo/point.py</code> <pre><code>def __init__(self, x: int | float, y: int | float, z: int | float) -&gt; None:\n    \"\"\"Initialization method.\n\n    Args:\n        x: Point x coordinate.\n        y: Point y coordinate.\n        z: Point z coordinate.\n    \"\"\"\n    self.x, self.y, self.z = x, y, z\n</code></pre>"},{"location":"doc-pages/Point/#pymesh.geo.point.Point.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of point instance</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Returns a copy of point instance\"\"\"\n    return Point(self.x, self.y, self.z)\n</code></pre>"},{"location":"doc-pages/Point/#pymesh.geo.point.Point.move","title":"move","text":"<pre><code>move(dx, dy, dz)\n</code></pre> <p>Moves the point coordinates in space.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>int | float</code> <p>Distance moved in the x-direction.</p> required <code>dy</code> <code>int | float</code> <p>Distance moved in the y-direction.</p> required <code>dz</code> <code>int | float</code> <p>Distance moved in the z-direction.</p> required <p>Returns:</p> Type Description <code>Point</code> <p>Point with updated xyz coordinates.</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>def move(self, dx: int | float, dy: int | float, dz: int | float) -&gt; Self:\n    \"\"\"Moves the point coordinates in space.\n\n    Args:\n        dx: Distance moved in the x-direction.\n        dy: Distance moved in the y-direction.\n        dz: Distance moved in the z-direction.\n\n    Returns:\n        (Point): Point with updated xyz coordinates.\n    \"\"\"\n    for val in (dx, dy, dz):\n        if not isinstance(val, (int, float)):\n            raise TypeError(f\"Expected {val!r} to be an int or float\")\n    self.x += float(dx)\n    self.y += float(dy)\n    self.z += float(dz)\n    return self\n</code></pre>"},{"location":"doc-pages/Point/#pymesh.geo.point.Point.rotate","title":"rotate","text":"<pre><code>rotate(angle, a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Rotates point around an axis.</p> <p>Parameters are passed to pymesh.utils.rotate_point_xyz.</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>def rotate(\n    self,\n    angle: int | float,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; Self:\n    \"\"\"Rotates point around an axis.\n\n    Parameters are passed to [pymesh.utils.rotate_point_xyz][].\n    \"\"\"\n    self.x, self.y, self.z = rotate_point_xyz(\n        self.x, self.y, self.z, angle, a, b, c, x0, y0, z0\n    )\n    return self\n</code></pre>"},{"location":"doc-pages/Point/#pymesh.geo.point.Point.mirror","title":"mirror","text":"<pre><code>mirror(a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Mirrors point in a plane.</p> <p>Parameters are passed to pymesh.utils.mirror_point_xyz.</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>def mirror(\n    self,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; Self:\n    \"\"\"Mirrors point in a plane.\n\n    Parameters are passed to [pymesh.utils.mirror_point_xyz][].\n    \"\"\"\n    self.x, self.y, self.z = mirror_point_xyz(\n        self.x, self.y, self.z, a, b, c, x0, y0, z0\n    )\n    return self\n</code></pre>"},{"location":"doc-pages/Point/#pymesh.geo.point.Point.get_distance_to","title":"get_distance_to","text":"<pre><code>get_distance_to(point)\n</code></pre> <p>Returns the shortest distance between point instance and another point</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Self</code> <p>Other point from which the distance is calculated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Direct distance between this and other point.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If point is not of type Self.</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>def get_distance_to(self, point: Self) -&gt; float:\n    \"\"\"Returns the shortest distance between point instance and another point\n\n    Args:\n        point: Other point from which the distance is calculated.\n\n    Returns:\n        (float): Direct distance between this and other point.\n\n    Raises:\n        TypeError: If point is not of type Self.\n    \"\"\"\n    if not isinstance(point, Point):\n        raise TypeError(f\"point must be of type '{Point.__name__}'.\")\n    dx = self.x - point.x\n    dy = self.y - point.y\n    dz = self.z - point.z\n    return math.sqrt(dx**2 + dy**2 + dz**2)\n</code></pre>"},{"location":"doc-pages/Point/#pymesh.geo.point.Point.create_relative_point","title":"create_relative_point","text":"<pre><code>create_relative_point(dx=0, dy=0, dz=0)\n</code></pre> <p>Creates a new point using relative positional arguments.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>int | float</code> <p>Relative x coordinate.</p> <code>0</code> <code>dy</code> <code>int | float</code> <p>Relative y coordinate.</p> <code>0</code> <code>dz</code> <code>int | float</code> <p>Relative z coordinate.</p> <code>0</code> <p>Returns:</p> Type Description <code>Point</code> <p>New point based on relative coordinates.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If dx, dy or dz are not of type int or float.</p> <code>ValueError</code> <p>If both dx, dy and dz are equal to zero.</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>def create_relative_point(\n    self, dx: int | float = 0, dy: int | float = 0, dz: int | float = 0\n) -&gt; Self:\n    \"\"\"Creates a new point using relative positional arguments.\n\n    Args:\n        dx: Relative x coordinate.\n        dy: Relative y coordinate.\n        dz: Relative z coordinate.\n\n    Returns:\n        (Point): New point based on relative coordinates.\n\n    Raises:\n        TypeError: If dx, dy or dz are not of type int or float.\n        ValueError: If both dx, dy and dz are equal to zero.\n    \"\"\"\n    for value in (dx, dy, dz):\n        if not isinstance(value, (int, float)):\n            raise TypeError(\"Relative position must be of type 'float' or 'int'\")\n    if (dx == 0.0) and (dy == 0.0) and (dz == 0.0):\n        raise ValueError(\"A non-zero relative position must be given\")\n    x = self.x + float(dx)\n    y = self.y + float(dy)\n    z = self.z + float(dz)\n    return Point(x, y, z)\n</code></pre>"},{"location":"doc-pages/PowerDistribution/","title":"PowerDistribution","text":"<p>               Bases: <code>MeshDistribution</code></p> <p>Power path distribution class expression: fn(u) = u**power expression: fn(u) = u</p> <p>For more information, see MeshDistribution.</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>class PowerDistribution(MeshDistribution):\n    \"\"\"Power path distribution class\n    expression: fn(u) = u**power\n    expression: fn(u) = u\n\n    For more information, see [MeshDistribution][pymesh.mesh.mesh_distributions.MeshDistribution].\n    \"\"\"\n\n    power = AsNumber(return_type=float)\n\n    def __init__(self, power: int | float = 1.0, flip_direction: bool = False):\n        super().__init__(flip_direction=flip_direction)\n        self.power = power\n\n    def copy(self) -&gt; Self:\n        return PowerDistribution(self.power, self.flip_direction)\n\n    def get_dist_fn(self):\n        flip = True if self.flip_direction else False  # breaks ref to self\n\n        def fn(u: int | float, flip_direction: bool = flip) -&gt; float:\n            u = self.validate_fn_input(u=u, flip_direction=flip_direction)\n            exp = u**self.power\n            return self.flip_exp(exp, flip_direction)\n\n        return fn\n</code></pre>"},{"location":"doc-pages/RuledSurface/","title":"RuledSurface","text":"<p>               Bases: <code>Surface</code></p> <p>Creates a ruled surface based on two opposing boundary curves.</p> <p>Attributes:</p> Name Type Description <code>curve1</code> <code>Curve</code> <p>Curve defining one surface boundary.</p> <code>curve2</code> <code>Curve</code> <p>Curve defining opposing surface boundary.</p> Source code in <code>pymesh/geo/surfaces/ruled_surface.py</code> <pre><code>class RuledSurface(Surface):\n    \"\"\"Creates a ruled surface based on two opposing boundary curves.\n\n    Attributes:\n        curve1 (Curve): Curve defining one surface boundary.\n        curve2 (Curve): Curve defining opposing surface boundary.\n    \"\"\"\n\n    curve1 = AsInstanceOf(Curve)\n    curve2 = AsInstanceOf(Curve)\n\n    def __init__(self, curve1: Curve, curve2: Curve):\n        \"\"\"Initialization method.\n\n        Args:\n            curve1: Curve defining one surface boundary.\n            curve2: Curve defining opposing surface boundary.\n\n        Raises:\n            TypeError: If curve1 or curve2 are not of type Curve.\n        \"\"\"\n        self._all_surfaces.append(self)\n        self.curve1 = curve1\n        self.curve2 = curve2\n\n    def __eq__(self, other):\n        return self.curve1 == other.curve1 and self.curve2 == other.curve2\n\n    def __repr__(self):\n        return f\"{type(self).__name__}(curve1={self.curve1!r}, curve2={self.curve2!r})\"\n\n    def get_max_lengths(self) -&gt; tuple[float]:\n        length_u = max(self.curve1.length, self.curve2.length)\n        length_w = max(\n            float(np.sqrt(np.sum((self.curve1.start - self.curve2.start) ** 2))),\n            float(np.sqrt(np.sum((self.curve1.end - self.curve2.end) ** 2))),\n        )\n        return length_u, length_w\n\n    def path(\n        self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n    ) -&gt; NDArray3[np.float64]:\n        u, w = validate_surface_path_parameters(u, w, uflip, wflip)\n        return (1 - w) * self.curve1.path(u) + w * self.curve2.path(u)\n\n    def copy(self) -&gt; Self:\n        copy = RuledSurface(self.curve1.copy(), self.curve2.copy())\n        copy._is_normal_flipped = self._is_normal_flipped\n        return copy\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.curve1.move(dx, dy, dz)\n        self.curve2.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.curve1.rotate(angle, a, b, c, x0, y0, z0)\n        self.curve2.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.curve1.mirror(a, b, c, x0, y0, z0)\n        self.curve2.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/RuledSurface/#pymesh.geo.surfaces.ruled_surface.RuledSurface.__init__","title":"__init__","text":"<pre><code>__init__(curve1, curve2)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>curve1</code> <code>Curve</code> <p>Curve defining one surface boundary.</p> required <code>curve2</code> <code>Curve</code> <p>Curve defining opposing surface boundary.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If curve1 or curve2 are not of type Curve.</p> Source code in <code>pymesh/geo/surfaces/ruled_surface.py</code> <pre><code>def __init__(self, curve1: Curve, curve2: Curve):\n    \"\"\"Initialization method.\n\n    Args:\n        curve1: Curve defining one surface boundary.\n        curve2: Curve defining opposing surface boundary.\n\n    Raises:\n        TypeError: If curve1 or curve2 are not of type Curve.\n    \"\"\"\n    self._all_surfaces.append(self)\n    self.curve1 = curve1\n    self.curve2 = curve2\n</code></pre>"},{"location":"doc-pages/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Point</li> <li>Curves<ul> <li>Curve</li> <li>Line</li> <li>ArcP3</li> <li>ArcPVA</li> <li>Bezier</li> </ul> </li> <li>Surfaces<ul> <li>Surface</li> <li>PlaneSurface</li> <li>RuledSurface</li> <li>BilinearSurface</li> <li>SweptSurface</li> <li>CoonsPatch</li> </ul> </li> <li>Mesh<ul> <li>MeshGenerator</li> <li>MeshDistributions:<ul> <li>MeshDistribution</li> <li>LinearDistribution</li> <li>CosineDistribution</li> <li>ExponentialDistribution</li> <li>PowerDistribution</li> </ul> </li> <li>MeshViewer</li> </ul> </li> <li>Writers<ul> <li>GDFWriter</li> </ul> </li> <li>Utils</li> <li>Typing</li> </ul>"},{"location":"doc-pages/Surface/","title":"Surface","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class used which all surface classes inherit from.</p> <p>Attributes:</p> Name Type Description <code>is_normal_flipped</code> <code>bool</code> <p>Specifies surface normal direction.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>class Surface(ABC):\n    \"\"\"Abstract base class used which all surface classes inherit from.\n\n    Attributes:\n        is_normal_flipped (bool): Specifies surface normal direction.\n    \"\"\"\n\n    _all_surfaces: list = []\n    _is_normal_flipped: bool = False\n\n    @property\n    def is_normal_flipped(self) -&gt; bool:\n        return self._is_normal_flipped\n\n    @classmethod\n    def get_all_surfaces(cls) -&gt; tuple[Surface]:\n        \"\"\"Returns a list of all generated surfaces, independent of surface class name.\"\"\"\n        return tuple(cls._all_surfaces)\n\n    def flip_normal(self) -&gt; Self:\n        \"\"\"Flips surface normal\"\"\"\n        self._is_normal_flipped = not self._is_normal_flipped\n        return self\n\n    @abstractmethod\n    def copy(self) -&gt; Self:\n        \"\"\"Returns a recursive copy of surface instance.\"\"\"\n\n    @abstractmethod\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        \"\"\"Moves the surface a given relative position in space.\n\n        Args:\n            dx: Distance moved in the x-direction.\n            dy: Distance moved in the y-direction.\n            dz: Distance moved in the z-direction.\n\n        Returns:\n            (Surface): Surface with updated xyz coordinates.\n\n        Raises:\n            TypeError: If dx, dy or dz are not of type int or float.\n            ValueError: If dx, dy and dz are all zero.\n        \"\"\"\n\n    @abstractmethod\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        \"\"\"Rotates surface around an axis.\n\n        Implementation based on [WikiPedia](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n\n        Args:\n            angle: Angle in radians.\n                Poitive direction defined as counter-clockwise, based on the right-hand rule.\n            a: Axis vector x direction.\n            b: Axis vector y direction.\n            c: Axis vector z direction.\n            x0: Axis base x coordinate\n                Default is zero.\n            y0: Axis base y coordinate\n                Default is zero.\n            z0: Axis base z coordinate\n                Default is zero.\n\n        Returns:\n            (Surface): Rotated surface instance.\n\n        Raises:\n            TypeError: If input value are not of type int or float.\n        \"\"\"\n\n    @abstractmethod\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        \"\"\"Mirrors surface in a plane.\n\n        Plane is defined by a plane normal vector (a, b, c) and a point (x0, y0, z0) in the plane.\n        Implementation based on formulation by [Jean Marie](https://math.stackexchange.com/questions/3927881/reflection-over-planes-in-3d).\n\n        Args:\n            a: Plane normal vector x dimension.\n            b: Plane normal vector y dimension.\n            c: Plane normal vector z dimension.\n            x0: Plane normal vector base x coordinate\n                Default is zero.\n            y0: Plane normal vector base y coordinate\n                Default is zero.\n            z0: Plane normal vector base z coordinate\n                Default is zero.\n\n        Returns:\n            (Surface): Mirrored surface instance.\n\n        Raises:\n            TypeError: If input value are not of type int or float.\n        \"\"\"\n\n    def get_path(\n        self,\n    ) -&gt; Callable[[int | float, int | float, bool, bool], NDArray3[np.float64]]:\n        \"\"\"Returns surface path function\"\"\"\n        return self.path\n\n    @abstractmethod\n    def path(\n        self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n    ) -&gt; NDArray3[np.float64]:\n        \"\"\"Surface path function that converts two normalized inputs u and w to a physical xyz point on the surface.\n\n        Args:\n            u: Normalized surface dimension path parameter between 0 and 1,\n                where 0 and 1 represents the start and end locations, respectively.\n            w: Normalized surface dimension path parameter between 0 and 1,\n                where 0 and 1 represents the start and end locations, respectively.\n            uflip: Defaults to False.\n                If True then u = (1 - u), i.e. the direction is flipped.\n            wflip: Defaults to False.\n                If True then w = (1 - w), i.e. the direction is flipped.\n\n        Returns:\n            (NDArray3[float]): Numpy ndarray with shape (3,)\n\n        Raises:\n            TypeError: If u or w are not of type int or float.\n            ValueError: If u or w are not part of the number set [0 1].\n        \"\"\"\n\n    @abstractmethod\n    def get_max_lengths(self) -&gt; tuple[float]:\n        \"\"\"Returns a tuple of shape (2,) with the longest surface\n        boundary length along each of the u and w dimensions. Indices\n        0 and 1 represent the u and w dimensions, respectively.\n        \"\"\"\n</code></pre>"},{"location":"doc-pages/Surface/#pymesh.geo.surfaces.surface.Surface.get_all_surfaces","title":"get_all_surfaces  <code>classmethod</code>","text":"<pre><code>get_all_surfaces()\n</code></pre> <p>Returns a list of all generated surfaces, independent of surface class name.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@classmethod\ndef get_all_surfaces(cls) -&gt; tuple[Surface]:\n    \"\"\"Returns a list of all generated surfaces, independent of surface class name.\"\"\"\n    return tuple(cls._all_surfaces)\n</code></pre>"},{"location":"doc-pages/Surface/#pymesh.geo.surfaces.surface.Surface.flip_normal","title":"flip_normal","text":"<pre><code>flip_normal()\n</code></pre> <p>Flips surface normal</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>def flip_normal(self) -&gt; Self:\n    \"\"\"Flips surface normal\"\"\"\n    self._is_normal_flipped = not self._is_normal_flipped\n    return self\n</code></pre>"},{"location":"doc-pages/Surface/#pymesh.geo.surfaces.surface.Surface.copy","title":"copy  <code>abstractmethod</code>","text":"<pre><code>copy()\n</code></pre> <p>Returns a recursive copy of surface instance.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@abstractmethod\ndef copy(self) -&gt; Self:\n    \"\"\"Returns a recursive copy of surface instance.\"\"\"\n</code></pre>"},{"location":"doc-pages/Surface/#pymesh.geo.surfaces.surface.Surface.move","title":"move  <code>abstractmethod</code>","text":"<pre><code>move(dx=0.0, dy=0.0, dz=0.0)\n</code></pre> <p>Moves the surface a given relative position in space.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>int | float</code> <p>Distance moved in the x-direction.</p> <code>0.0</code> <code>dy</code> <code>int | float</code> <p>Distance moved in the y-direction.</p> <code>0.0</code> <code>dz</code> <code>int | float</code> <p>Distance moved in the z-direction.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Surface</code> <p>Surface with updated xyz coordinates.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If dx, dy or dz are not of type int or float.</p> <code>ValueError</code> <p>If dx, dy and dz are all zero.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@abstractmethod\ndef move(\n    self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n) -&gt; Self:\n    \"\"\"Moves the surface a given relative position in space.\n\n    Args:\n        dx: Distance moved in the x-direction.\n        dy: Distance moved in the y-direction.\n        dz: Distance moved in the z-direction.\n\n    Returns:\n        (Surface): Surface with updated xyz coordinates.\n\n    Raises:\n        TypeError: If dx, dy or dz are not of type int or float.\n        ValueError: If dx, dy and dz are all zero.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/Surface/#pymesh.geo.surfaces.surface.Surface.rotate","title":"rotate  <code>abstractmethod</code>","text":"<pre><code>rotate(angle, a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Rotates surface around an axis.</p> <p>Implementation based on WikiPedia.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>int | float</code> <p>Angle in radians. Poitive direction defined as counter-clockwise, based on the right-hand rule.</p> required <code>a</code> <code>int | float</code> <p>Axis vector x direction.</p> required <code>b</code> <code>int | float</code> <p>Axis vector y direction.</p> required <code>c</code> <code>int | float</code> <p>Axis vector z direction.</p> required <code>x0</code> <code>int | float</code> <p>Axis base x coordinate Default is zero.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Axis base y coordinate Default is zero.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Axis base z coordinate Default is zero.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Surface</code> <p>Rotated surface instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input value are not of type int or float.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@abstractmethod\ndef rotate(\n    self,\n    angle: int | float,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; Self:\n    \"\"\"Rotates surface around an axis.\n\n    Implementation based on [WikiPedia](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n\n    Args:\n        angle: Angle in radians.\n            Poitive direction defined as counter-clockwise, based on the right-hand rule.\n        a: Axis vector x direction.\n        b: Axis vector y direction.\n        c: Axis vector z direction.\n        x0: Axis base x coordinate\n            Default is zero.\n        y0: Axis base y coordinate\n            Default is zero.\n        z0: Axis base z coordinate\n            Default is zero.\n\n    Returns:\n        (Surface): Rotated surface instance.\n\n    Raises:\n        TypeError: If input value are not of type int or float.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/Surface/#pymesh.geo.surfaces.surface.Surface.mirror","title":"mirror  <code>abstractmethod</code>","text":"<pre><code>mirror(a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Mirrors surface in a plane.</p> <p>Plane is defined by a plane normal vector (a, b, c) and a point (x0, y0, z0) in the plane. Implementation based on formulation by Jean Marie.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | float</code> <p>Plane normal vector x dimension.</p> required <code>b</code> <code>int | float</code> <p>Plane normal vector y dimension.</p> required <code>c</code> <code>int | float</code> <p>Plane normal vector z dimension.</p> required <code>x0</code> <code>int | float</code> <p>Plane normal vector base x coordinate Default is zero.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Plane normal vector base y coordinate Default is zero.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Plane normal vector base z coordinate Default is zero.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Surface</code> <p>Mirrored surface instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input value are not of type int or float.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@abstractmethod\ndef mirror(\n    self,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; Self:\n    \"\"\"Mirrors surface in a plane.\n\n    Plane is defined by a plane normal vector (a, b, c) and a point (x0, y0, z0) in the plane.\n    Implementation based on formulation by [Jean Marie](https://math.stackexchange.com/questions/3927881/reflection-over-planes-in-3d).\n\n    Args:\n        a: Plane normal vector x dimension.\n        b: Plane normal vector y dimension.\n        c: Plane normal vector z dimension.\n        x0: Plane normal vector base x coordinate\n            Default is zero.\n        y0: Plane normal vector base y coordinate\n            Default is zero.\n        z0: Plane normal vector base z coordinate\n            Default is zero.\n\n    Returns:\n        (Surface): Mirrored surface instance.\n\n    Raises:\n        TypeError: If input value are not of type int or float.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/Surface/#pymesh.geo.surfaces.surface.Surface.get_path","title":"get_path","text":"<pre><code>get_path()\n</code></pre> <p>Returns surface path function</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>def get_path(\n    self,\n) -&gt; Callable[[int | float, int | float, bool, bool], NDArray3[np.float64]]:\n    \"\"\"Returns surface path function\"\"\"\n    return self.path\n</code></pre>"},{"location":"doc-pages/Surface/#pymesh.geo.surfaces.surface.Surface.path","title":"path  <code>abstractmethod</code>","text":"<pre><code>path(u, w, uflip=False, wflip=False)\n</code></pre> <p>Surface path function that converts two normalized inputs u and w to a physical xyz point on the surface.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>int | float</code> <p>Normalized surface dimension path parameter between 0 and 1, where 0 and 1 represents the start and end locations, respectively.</p> required <code>w</code> <code>int | float</code> <p>Normalized surface dimension path parameter between 0 and 1, where 0 and 1 represents the start and end locations, respectively.</p> required <code>uflip</code> <code>bool</code> <p>Defaults to False. If True then u = (1 - u), i.e. the direction is flipped.</p> <code>False</code> <code>wflip</code> <code>bool</code> <p>Defaults to False. If True then w = (1 - w), i.e. the direction is flipped.</p> <code>False</code> <p>Returns:</p> Type Description <code>NDArray3[float]</code> <p>Numpy ndarray with shape (3,)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If u or w are not of type int or float.</p> <code>ValueError</code> <p>If u or w are not part of the number set [0 1].</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@abstractmethod\ndef path(\n    self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n) -&gt; NDArray3[np.float64]:\n    \"\"\"Surface path function that converts two normalized inputs u and w to a physical xyz point on the surface.\n\n    Args:\n        u: Normalized surface dimension path parameter between 0 and 1,\n            where 0 and 1 represents the start and end locations, respectively.\n        w: Normalized surface dimension path parameter between 0 and 1,\n            where 0 and 1 represents the start and end locations, respectively.\n        uflip: Defaults to False.\n            If True then u = (1 - u), i.e. the direction is flipped.\n        wflip: Defaults to False.\n            If True then w = (1 - w), i.e. the direction is flipped.\n\n    Returns:\n        (NDArray3[float]): Numpy ndarray with shape (3,)\n\n    Raises:\n        TypeError: If u or w are not of type int or float.\n        ValueError: If u or w are not part of the number set [0 1].\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/Surface/#pymesh.geo.surfaces.surface.Surface.get_max_lengths","title":"get_max_lengths  <code>abstractmethod</code>","text":"<pre><code>get_max_lengths()\n</code></pre> <p>Returns a tuple of shape (2,) with the longest surface boundary length along each of the u and w dimensions. Indices 0 and 1 represent the u and w dimensions, respectively.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@abstractmethod\ndef get_max_lengths(self) -&gt; tuple[float]:\n    \"\"\"Returns a tuple of shape (2,) with the longest surface\n    boundary length along each of the u and w dimensions. Indices\n    0 and 1 represent the u and w dimensions, respectively.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/SweptSurface/","title":"SweptSurface","text":"<p>               Bases: <code>Surface</code></p> <p>Creates a swept surface from a curve and a sweeper curve.</p> <p>Attributes:</p> Name Type Description <code>curve</code> <code>Curve</code> <p>Curve defining the path to be swept.</p> <code>sweeper</code> <code>Curve</code> <p>Curve defining the path curve is swept along.</p> Source code in <code>pymesh/geo/surfaces/swept_surface.py</code> <pre><code>class SweptSurface(Surface):\n    \"\"\"Creates a swept surface from a curve and a sweeper curve.\n\n    Attributes:\n        curve (Curve): Curve defining the path to be swept.\n        sweeper (Curve): Curve defining the path curve is swept along.\n    \"\"\"\n\n    curve = AsInstanceOf(Curve)\n    sweeper = AsInstanceOf(Curve)\n\n    def __init__(self, curve: Curve, sweeper: Curve):\n        \"\"\"Initialization method.\n\n        Args:\n            curve: Curve defining the path to be swept.\n            sweeper: Curve defining the path curve is swept along.\n\n        Raises:\n            TypeError: If curve or sweeper are not of type Curve.\n        \"\"\"\n        self._all_surfaces.append(self)\n        self.curve = curve\n        self.sweeper = sweeper\n\n    def __eq__(self, other):\n        return self.curve == other.curve and self.sweeper == other.sweeper\n\n    def __repr__(self):\n        return f\"{type(self).__name__}(curve={self.curve!r}, sweeper={self.sweeper!r})\"\n\n    def get_max_lengths(self) -&gt; tuple[float]:\n        return self.curve.length, self.sweeper.length\n\n    def path(\n        self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n    ) -&gt; NDArray3[np.float64]:\n        u, w = validate_surface_path_parameters(u, w, uflip, wflip)\n        sweep = self.sweeper.path(w) - self.sweeper.path(0)\n        return self.curve.path(u) + sweep\n\n    def copy(self) -&gt; Self:\n        copy = SweptSurface(self.curve.copy(), self.sweeper.copy())\n        copy._is_normal_flipped = self._is_normal_flipped\n        return copy\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.curve.move(dx, dy, dz)\n        self.sweeper.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.curve.rotate(angle, a, b, c, x0, y0, z0)\n        self.sweeper.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.curve.mirror(a, b, c, x0, y0, z0)\n        self.sweeper.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/SweptSurface/#pymesh.geo.surfaces.swept_surface.SweptSurface.__init__","title":"__init__","text":"<pre><code>__init__(curve, sweeper)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>curve</code> <code>Curve</code> <p>Curve defining the path to be swept.</p> required <code>sweeper</code> <code>Curve</code> <p>Curve defining the path curve is swept along.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If curve or sweeper are not of type Curve.</p> Source code in <code>pymesh/geo/surfaces/swept_surface.py</code> <pre><code>def __init__(self, curve: Curve, sweeper: Curve):\n    \"\"\"Initialization method.\n\n    Args:\n        curve: Curve defining the path to be swept.\n        sweeper: Curve defining the path curve is swept along.\n\n    Raises:\n        TypeError: If curve or sweeper are not of type Curve.\n    \"\"\"\n    self._all_surfaces.append(self)\n    self.curve = curve\n    self.sweeper = sweeper\n</code></pre>"},{"location":"doc-pages/Typing/","title":"Typing","text":""},{"location":"doc-pages/Typing/#pymesh.typing.NDArray3","title":"NDArray3  <code>module-attribute</code>","text":"<pre><code>NDArray3 = Annotated[NDArray[DType], Literal[3]]\n</code></pre> <p>Numpy ndarray with shape (3, ).</p>"},{"location":"doc-pages/Typing/#pymesh.typing.NDArray3xNxN","title":"NDArray3xNxN  <code>module-attribute</code>","text":"<pre><code>NDArray3xNxN = Annotated[NDArray[DType], Literal[3, 'N', 'N']]\n</code></pre> <p>Numpy ndarray with shape (3, N, N).</p>"},{"location":"doc-pages/Utils/","title":"Utils","text":"<p>Package utility functions.</p> Geometry helper functions <ul> <li>rotate_point_xyz</li> <li>mirror_point_xyz</li> </ul> Validation functions <ul> <li>validate_curve_path_parameters</li> <li>validate_surface_path_parameters</li> </ul> Benchmark functions <ul> <li>time_it</li> </ul>"},{"location":"doc-pages/Utils/#pymesh.utils.time_it","title":"time_it","text":"<pre><code>time_it(func)\n</code></pre> <p>Wrapper function used to time function execution time</p> Source code in <code>pymesh/utils.py</code> <pre><code>def time_it(func):\n    \"\"\"Wrapper function used to time function execution time\"\"\"\n\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(\n            f\"Exceution of '{func.__name__}' took {round((end - start) * 1000)} mil sec.\"\n        )\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"doc-pages/Utils/#pymesh.utils.rotate_point_xyz","title":"rotate_point_xyz","text":"<pre><code>rotate_point_xyz(x, y, z, angle, a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Rotates point around an axis.</p> <p>Implementation based on WikiPedia.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>int | float</code> <p>Angle in radians Poitive direction defined as counter-clockwise, based on the right-hand rule.</p> required <code>a</code> <code>int | float</code> <p>Axis vector x direction.</p> required <code>b</code> <code>int | float</code> <p>Axis vector y direction.</p> required <code>c</code> <code>int | float</code> <p>Axis vector z direction.</p> required <code>x0</code> <code>int | float</code> <p>Axis base x coordinate Default is origin of coordinate system.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Axis base y coordinate Default is origin of coordinate system.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Axis base z coordinate Default is origin of coordinate system.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>NDArray3</code> <p>Rotated point xyz coordinates given as a numpy array shaped (3,)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input value are not of type int or float.</p> Source code in <code>pymesh/utils.py</code> <pre><code>def rotate_point_xyz(\n    x: int | float,\n    y: int | float,\n    z: int | float,\n    angle: int | float,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; NDArray3:\n    \"\"\"Rotates point around an axis.\n\n    Implementation based on [WikiPedia](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n\n    Args:\n        angle (int | float): Angle in radians\n            Poitive direction defined as counter-clockwise,\n            based on the right-hand rule.\n        a (int | float): Axis vector x direction.\n        b (int | float): Axis vector y direction.\n        c (int | float): Axis vector z direction.\n        x0 (int | float, optional): Axis base x coordinate\n            Default is origin of coordinate system.\n        y0 (int | float, optional): Axis base y coordinate\n            Default is origin of coordinate system.\n        z0 (int | float, optional): Axis base z coordinate\n            Default is origin of coordinate system.\n\n    Returns:\n        (NDArray3): Rotated point xyz coordinates\n            given as a numpy array shaped (3,)\n\n    Raises:\n        TypeError: If input value are not of type int or float.\n    \"\"\"\n    for val in (x, y, z, angle, a, b, c, x0, y0, z0):\n        if not isinstance(val, (int, float)):\n            raise TypeError(f\"Expected {val!r} to be int or float\")\n    xyz = np.array([x, y, z])\n    xyz0 = np.array([x0, y0, z0])\n    abc = np.array([a, b, c])\n    avec = abc / math.sqrt(np.sum(abc**2))\n    pvec = xyz - xyz0\n    part1 = pvec * math.cos(angle)\n    part2 = np.cross(avec, pvec) * math.sin(angle)\n    part3 = avec * np.dot(avec, pvec) * (1 - math.cos(angle))\n    return xyz0 + part1 + part2 + part3\n</code></pre>"},{"location":"doc-pages/Utils/#pymesh.utils.mirror_point_xyz","title":"mirror_point_xyz","text":"<pre><code>mirror_point_xyz(x, y, z, a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Mirrors xyz point in a plane.</p> <p>Implementation based on formulation by Jean Marie.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int | float</code> <p>Point x coordinate.</p> required <code>y</code> <code>int | float</code> <p>Point y coordinate.</p> required <code>z</code> <code>int | float</code> <p>Point z coordinate.</p> required <code>a</code> <code>int | float</code> <p>Plane normal vector x dimension.</p> required <code>b</code> <code>int | float</code> <p>Plane normal vector y dimension.</p> required <code>c</code> <code>int | float</code> <p>Plane normal vector z dimension.</p> required <code>x0</code> <code>int | float</code> <p>Plane normal vector base x coordinate Default is origin of coordinate system.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Plane normal vector base y coordinate Default is origin of coordinate system.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Plane normal vector base z coordinate Default is origin of coordinate system.</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>NDArray3</code> <code>NDArray3</code> <p>Rotated point xyz coordinates given as a numpy array shaped (3,)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input value are not of type int or float.</p> Source code in <code>pymesh/utils.py</code> <pre><code>def mirror_point_xyz(\n    x: int | float,\n    y: int | float,\n    z: int | float,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; NDArray3:\n    \"\"\"Mirrors xyz point in a plane.\n\n    Implementation based on formulation by [Jean Marie](https://math.stackexchange.com/questions/3927881/reflection-over-planes-in-3d).\n\n    Args:\n        x (int | float): Point x coordinate.\n        y (int | float): Point y coordinate.\n        z (int | float): Point z coordinate.\n        a (int | float): Plane normal vector x dimension.\n        b (int | float): Plane normal vector y dimension.\n        c (int | float): Plane normal vector z dimension.\n        x0 (int | float, optional): Plane normal vector base x coordinate\n            Default is origin of coordinate system.\n        y0 (int | float, optional): Plane normal vector base y coordinate\n            Default is origin of coordinate system.\n        z0 (int | float, optional): Plane normal vector base z coordinate\n            Default is origin of coordinate system.\n\n    Returns:\n        NDArray3: Rotated point xyz coordinates\n            given as a numpy array shaped (3,)\n\n    Raises:\n        TypeError: If input value are not of type int or float.\n    \"\"\"\n    for val in (x, y, z, a, b, c, x0, y0, z0):\n        if not isinstance(val, (int, float)):\n            raise TypeError(f\"Expected {val!r} to be int or float\")\n    xyz = np.array([x, y, z])\n    xyz0 = np.array([x0, y0, z0])\n    abc = np.array([a, b, c])\n    a, b, c = abc / math.sqrt(np.sum(abc**2))\n    transformation_matrix = np.array(\n        [\n            [1 - 2 * a * a, -2 * a * b, -2 * a * c],\n            [-2 * a * b, 1 - 2 * b * b, -2 * b * c],\n            [-2 * a * c, -2 * b * c, 1 - 2 * c * c],\n        ]\n    )\n    return transformation_matrix.dot(xyz - xyz0) + xyz0\n</code></pre>"},{"location":"doc-pages/Utils/#pymesh.utils.validate_curve_path_parameters","title":"validate_curve_path_parameters","text":"<pre><code>validate_curve_path_parameters(u, flip=False)\n</code></pre> <p>Validates the normalized curve path parameter.</p> <p>Args: u (int | float): Normalized path parameter between 0 and 1. flip (bool, optional): Default if False. If True,     then u = (1 - u), i.e. the direction is flipped.</p> <p>Returns:</p> Name Type Description <code>u</code> <code>float</code> <p>Normalized path paremeter between 0 and 1.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If u is not of type int or float</p> <code>ValueError</code> <p>If u is not part of the number set [0 1].</p> Source code in <code>pymesh/utils.py</code> <pre><code>def validate_curve_path_parameters(u: int | float, flip: bool = False) -&gt; float:\n    \"\"\"Validates the normalized curve path parameter.\n\n    Args:\n    u (int | float): Normalized path parameter between 0 and 1.\n    flip (bool, optional): Default if False. If True,\n        then u = (1 - u), i.e. the direction is flipped.\n\n\n    Returns:\n        u (float): Normalized path paremeter between 0 and 1.\n\n    Raises:\n        TypeError: If u is not of type int or float\n        ValueError: If u is not part of the number set [0 1].\n    \"\"\"\n    if not isinstance(u, (int, float)):\n        raise TypeError(f\"Expected an int or float number, but got {u!r}\")\n    if isinstance(u, int):\n        u = float(u)\n    if u &lt; 0 or 1 &lt; u:\n        raise ValueError(f\"Expected a value between 0 and 1 but got {u!r}\")\n    if flip:\n        u = 1 - u\n    return u\n</code></pre>"},{"location":"doc-pages/Utils/#pymesh.utils.validate_surface_path_parameters","title":"validate_surface_path_parameters","text":"<pre><code>validate_surface_path_parameters(u, w, uflip=False, wflip=False)\n</code></pre> <p>Validates the normalized surface path parameter.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>int | float</code> <p>Normalized path parameter between 0 and 1.</p> required <code>w</code> <code>int | float</code> <p>Normalized path parameter between 0 and 1.</p> required <code>uflip</code> <code>bool</code> <p>Default is False. If True, then u = (1 - u), i.e. the direction is flipped.</p> <code>False</code> <code>wflip</code> <code>bool</code> <p>Default is False. If True, then w = (1 - w), i.e. the direction is flipped.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple (u, w) with normalized parameters btween 0 and 1.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If u or w is not of type int or float</p> <code>ValueError</code> <p>If u or w is not part of the number set [0 1].</p> Source code in <code>pymesh/utils.py</code> <pre><code>def validate_surface_path_parameters(\n    u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n) -&gt; tuple[float, float]:\n    \"\"\"Validates the normalized surface path parameter.\n\n    Args:\n        u (int | float): Normalized path parameter between 0 and 1.\n        w (int | float): Normalized path parameter between 0 and 1.\n        uflip (bool, optional): Default is False. If True,\n            then u = (1 - u), i.e. the direction is flipped.\n        wflip (bool, optional): Default is False. If True,\n            then w = (1 - w), i.e. the direction is flipped.\n\n    Returns:\n        (tuple): Tuple (u, w) with normalized parameters btween 0 and 1.\n\n    Raises:\n        TypeError: If u or w is not of type int or float\n        ValueError: If u or w is not part of the number set [0 1].\n    \"\"\"\n    return (\n        validate_curve_path_parameters(u, uflip),\n        validate_curve_path_parameters(w, wflip),\n    )\n</code></pre>"},{"location":"doc-pages/auto-generated/","title":"pymesh","text":""},{"location":"doc-pages/auto-generated/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pymesh<ul> <li>descriptors</li> <li>docstrings</li> <li>exceptions</li> <li>geo<ul> <li>curves<ul> <li>arc3p</li> <li>arcpva</li> <li>bezier</li> <li>curve</li> <li>line</li> <li>user_defined_curve</li> </ul> </li> <li>point</li> <li>surfaces<ul> <li>bilinear_surface</li> <li>coons_patch</li> <li>plane_surface</li> <li>ruled_surface</li> <li>surface</li> <li>swept_surface</li> </ul> </li> </ul> </li> <li>mesh<ul> <li>mesh_distributions</li> <li>mesh_generator</li> <li>mesh_viewer</li> </ul> </li> <li>typing</li> <li>utils</li> <li>writers<ul> <li>gdf_writer</li> </ul> </li> </ul> </li> </ul>"},{"location":"doc-pages/auto-generated/descriptors/","title":"descriptors","text":"<p>Module containing generic class attribute descriptors</p>"},{"location":"doc-pages/auto-generated/descriptors/#pymesh.descriptors.Validator","title":"Validator","text":"<p>               Bases: <code>ABC</code></p> <p>Descriptor used for validating instance attributes of other classes. Based on: https://docs.python.org/3/howto/descriptor.html#validator-class.</p> Source code in <code>pymesh/descriptors.py</code> <pre><code>class Validator(ABC):\n    \"\"\"Descriptor used for validating instance attributes of other classes.\n    Based on: https://docs.python.org/3/howto/descriptor.html#validator-class.\n    \"\"\"\n\n    return_type: Callable | None = None\n\n    def __set_name__(self, obj, name):\n        self.private_name = \"_\" + name  # pylint: disable=attribute-defined-outside-init\n\n    def __get__(self, obj, objtype=None):\n        return getattr(obj, self.private_name)\n\n    def __set__(self, obj, value):\n        self.validate(value)\n        value_of_type = self.convert_to_type(value)\n        setattr(obj, self.private_name, value_of_type)\n\n    def convert_to_type(self, value):\n        if self.return_type is None:\n            return value\n        if not callable(self.return_type):\n            raise TypeError(f\"Expected {self.return_type:!r} to be callable\")\n        return self.return_type(value)  # pylint: disable=not-callable\n\n    @abstractmethod\n    def validate(self, value):\n        \"\"\"Validates value based on various relevant criteria\"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/descriptors/#pymesh.descriptors.Validator.validate","title":"validate  <code>abstractmethod</code>","text":"<pre><code>validate(value)\n</code></pre> <p>Validates value based on various relevant criteria</p> Source code in <code>pymesh/descriptors.py</code> <pre><code>@abstractmethod\ndef validate(self, value):\n    \"\"\"Validates value based on various relevant criteria\"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/descriptors/#pymesh.descriptors.AsNumber","title":"AsNumber","text":"<p>               Bases: <code>Validator</code></p> <p>Number descriptor validating int or float and setting type according to return_type. Based on: https://docs.python.org/3/howto/descriptor.html#custom-validators.</p> Source code in <code>pymesh/descriptors.py</code> <pre><code>class AsNumber(Validator):\n    \"\"\"Number descriptor validating int or float and setting type according to return_type.\n    Based on: https://docs.python.org/3/howto/descriptor.html#custom-validators.\n    \"\"\"\n\n    def __init__(\n        self,\n        minvalue: int | float | None = None,\n        maxvalue: int | float | None = None,\n        return_type: Callable | None = None,\n    ):\n        self.minvalue = minvalue\n        self.maxvalue = maxvalue\n        self.return_type = return_type\n\n    def validate(self, value):\n        if not isinstance(value, (int, float)):\n            raise TypeError(f\"Expected {value!r} to be an int or float\")\n        if self.minvalue is not None and value &lt; self.minvalue:\n            raise ValueError(f\"Expected {value!r} to be at least {self.minvalue!r}\")\n        if self.maxvalue is not None and value &gt; self.maxvalue:\n            raise ValueError(f\"Expected {value!r} to be no more than {self.maxvalue!r}\")\n</code></pre>"},{"location":"doc-pages/auto-generated/descriptors/#pymesh.descriptors.AsInstanceOf","title":"AsInstanceOf","text":"<p>               Bases: <code>Validator</code></p> <p>Descriptor validating that object is an instance of a specified class.</p> Source code in <code>pymesh/descriptors.py</code> <pre><code>class AsInstanceOf(Validator):\n    \"\"\"Descriptor validating that object is an instance of a specified class.\"\"\"\n\n    def __init__(self, cls):\n        self.cls = cls\n\n    def validate(self, value):\n        if not isinstance(value, self.cls):\n            raise TypeError(f\"Expected {value!r} to be an instance of {self.cls!r}\")\n</code></pre>"},{"location":"doc-pages/auto-generated/descriptors/#pymesh.descriptors.AsNDArray","title":"AsNDArray","text":"<p>               Bases: <code>Validator</code></p> <p>Descriptor validating that object is an instance of a numpy ndarray.</p> Source code in <code>pymesh/descriptors.py</code> <pre><code>class AsNDArray(Validator):\n    \"\"\"Descriptor validating that object is an instance of a numpy ndarray.\"\"\"\n\n    def __init__(\n        self,\n        shape: tuple[int],\n    ):\n        self.shape = shape\n\n    def __set__(self, obj, value: NDArray3[np.float64]):\n        super().__set__(obj, value)\n\n    def validate(self, arr):\n        if not isinstance(arr, np.ndarray):\n            raise TypeError(f\"Expected {arr!r} to be an instance of {np.ndarray!r}\")\n        assert (\n            arr.shape == self.shape\n        ), f\"Expected shape to be {self.shape!r} but received {arr.shape!r}\"\n</code></pre>"},{"location":"doc-pages/auto-generated/descriptors/#pymesh.descriptors.AsContainerOf","title":"AsContainerOf","text":"<p>               Bases: <code>Validator</code></p> Source code in <code>pymesh/descriptors.py</code> <pre><code>class AsContainerOf(Validator):\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        container_type,\n        item_type,\n        min_length: int | None = None,\n        max_length: int | None = None,\n    ):\n        self.container_type = container_type\n        self.item_type = item_type\n        self.min_length = min_length\n        self.max_length = max_length\n\n    def validate(self, value):\n        if not isinstance(value, self.container_type):\n            raise TypeError(f\"Expected {value!r} to be {self.container_type!r}\")\n        if self.min_length is not None and len(value) &lt; self.min_length:\n            raise ValueError(\n                f\"Expected {self.container_type!r} to have min {self.min_length!r} items\"\n            )\n        if self.max_length is not None and len(value) &gt; self.max_length:\n            raise ValueError(\n                f\"Expected {self.container_type!r} to have max {self.max_length!r} items\"\n            )\n        for item in value:\n            if not isinstance(item, self.item_type):\n                raise TypeError(f\"Expected {item!r} to be {self.item_type!r}\")\n</code></pre>"},{"location":"doc-pages/auto-generated/descriptors/#pymesh.descriptors.Property","title":"Property","text":"<p>               Bases: <code>ABC</code></p> <p>Emulate PyProperty_Type() in Objects/descrobject.c</p> <p>Copied from https://docs.python.org/3/howto/descriptor.html#properties</p> Source code in <code>pymesh/descriptors.py</code> <pre><code>class Property(ABC):\n    \"\"\"Emulate PyProperty_Type() in Objects/descrobject.c\n\n    Copied from https://docs.python.org/3/howto/descriptor.html#properties\n    \"\"\"\n\n    return_type: Callable | None = None\n\n    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n        self.fget = fget\n        self.fset = fset\n        self.fdel = fdel\n        if doc is None and fget is not None:\n            doc = fget.__doc__\n        self.__doc__ = doc\n        self._name = \"\"\n\n    def __set_name__(self, owner, name):\n        self._name = name\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        if self.fget is None:\n            raise AttributeError(\n                f\"property {self._name!r} of {type(obj).__name__!r} object has no getter\"\n            )\n        return self.fget(obj)\n\n    def __set__(self, obj, value):\n        if self.fset is None:\n            raise AttributeError(\n                f\"property {self._name!r} of {type(obj).__name__!r} object has no setter\"\n            )\n        self.validate(value)\n        value_of_type = self.convert_to_type(value)\n        self.fset(obj, value_of_type)\n\n    def __delete__(self, obj):\n        if self.fdel is None:\n            raise AttributeError(\n                f\"property {self._name!r} of {type(obj).__name__!r} object has no deleter\"\n            )\n        self.fdel(obj)\n\n    def getter(self, fget):\n        prop = type(self)(fget, self.fset, self.fdel, self.__doc__)\n        prop._name = self._name\n        return prop\n\n    def setter(self, fset):\n        prop = type(self)(self.fget, fset, self.fdel, self.__doc__)\n        prop._name = self._name\n        return prop\n\n    def deleter(self, fdel):\n        prop = type(self)(self.fget, self.fset, fdel, self.__doc__)\n        prop._name = self._name\n        return prop\n\n    def convert_to_type(self, value):\n        if self.return_type is None:\n            return value\n        if not callable(self.return_type):\n            raise TypeError(f\"Expected {self.return_type:!r} to be callable\")\n        return self.return_type(value)  # pylint: disable=not-callable\n\n    @abstractmethod\n    def validate(self, value):\n        \"\"\"Validates value based on various relevant criteria\"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/descriptors/#pymesh.descriptors.Property.validate","title":"validate  <code>abstractmethod</code>","text":"<pre><code>validate(value)\n</code></pre> <p>Validates value based on various relevant criteria</p> Source code in <code>pymesh/descriptors.py</code> <pre><code>@abstractmethod\ndef validate(self, value):\n    \"\"\"Validates value based on various relevant criteria\"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/descriptors/#pymesh.descriptors.MyProperty","title":"MyProperty","text":"<p>               Bases: <code>Property</code></p> <p>Copy of AsInstanceOf</p> Source code in <code>pymesh/descriptors.py</code> <pre><code>class MyProperty(Property):\n    \"\"\"Copy of AsInstanceOf\"\"\"\n\n    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n        super().__init__(fget, fset, fdel, doc)\n\n    def validate(self, value):\n        pass\n</code></pre>"},{"location":"doc-pages/auto-generated/docstrings/","title":"docstrings","text":"<p>Package module for testing docstring copy methods.</p> Note <p>Currently the @copy_docstring implementation does not work!</p>"},{"location":"doc-pages/auto-generated/docstrings/#pymesh.docstrings.DocstringTestClass","title":"DocstringTestClass","text":"Source code in <code>pymesh/docstrings.py</code> <pre><code>class DocstringTestClass:\n\n    def test_method(self, a: Any) -&gt; Any:\n        \"\"\"Test method.\n\n        Used for checking if the decorator @copy_docstring is working.\n\n        Args:\n            a: Input parameter.\n\n        Returns:\n            a: Output parameter.\n        \"\"\"\n        return a\n\n    @copy_docstring(test_method)\n    def test_method_with_copied_docstring(self, a: Any) -&gt; Any:\n        \"\"\"Dummy docstring, to be replaced.\"\"\"\n        return a\n</code></pre>"},{"location":"doc-pages/auto-generated/docstrings/#pymesh.docstrings.DocstringTestClass.test_method","title":"test_method","text":"<pre><code>test_method(a)\n</code></pre> <p>Test method.</p> <p>Used for checking if the decorator @copy_docstring is working.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Any</code> <p>Input parameter.</p> required <p>Returns:</p> Name Type Description <code>a</code> <code>Any</code> <p>Output parameter.</p> Source code in <code>pymesh/docstrings.py</code> <pre><code>def test_method(self, a: Any) -&gt; Any:\n    \"\"\"Test method.\n\n    Used for checking if the decorator @copy_docstring is working.\n\n    Args:\n        a: Input parameter.\n\n    Returns:\n        a: Output parameter.\n    \"\"\"\n    return a\n</code></pre>"},{"location":"doc-pages/auto-generated/docstrings/#pymesh.docstrings.DocstringTestClass.test_method_with_copied_docstring","title":"test_method_with_copied_docstring","text":"<pre><code>test_method_with_copied_docstring(a)\n</code></pre> <p>Dummy docstring, to be replaced.</p> Source code in <code>pymesh/docstrings.py</code> <pre><code>@copy_docstring(test_method)\ndef test_method_with_copied_docstring(self, a: Any) -&gt; Any:\n    \"\"\"Dummy docstring, to be replaced.\"\"\"\n    return a\n</code></pre>"},{"location":"doc-pages/auto-generated/docstrings/#pymesh.docstrings.copy_docstring","title":"copy_docstring","text":"<pre><code>copy_docstring(wrapper)\n</code></pre> <p>Copies the docstring of the given function to another.</p> <p>This function is intended to be used as a decorator.</p> <p>.. code-block:: python3</p> <pre><code>def foo(x: int, y: int) -&gt; str:\n'''I have a docstring and arguments'''\n    ...\n\n@copy_docstring(foo)\ndef bar():\n    ...\n</code></pre> Note <p>Above code block style works with in Visual Studio Code.</p> Source code in <code>pymesh/docstrings.py</code> <pre><code>def copy_docstring(wrapper: Callable[P, T]):\n    \"\"\"Copies the docstring of the given function to another.\n\n    This function is intended to be used as a decorator.\n\n    .. code-block:: python3\n\n        def foo(x: int, y: int) -&gt; str:\n        '''I have a docstring and arguments'''\n            ...\n\n        @copy_docstring(foo)\n        def bar():\n            ...\n\n    Note:\n        Above code block style works with in Visual Studio Code.\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable[P, T]:\n        func.__doc__ = wrapper.__doc__\n        return func\n\n    return decorator\n</code></pre>"},{"location":"doc-pages/auto-generated/docstrings/#pymesh.docstrings.test_fn","title":"test_fn","text":"<pre><code>test_fn(a)\n</code></pre> <p>Test function.</p> <p>Used for checking if the decorator @copy_docstring is working.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Any</code> <p>Input parameter.</p> required <p>Returns:</p> Name Type Description <code>a</code> <code>Any</code> <p>Output parameter.</p> Source code in <code>pymesh/docstrings.py</code> <pre><code>def test_fn(a: Any) -&gt; Any:\n    \"\"\"Test function.\n\n    Used for checking if the decorator @copy_docstring is working.\n\n    Args:\n        a: Input parameter.\n\n    Returns:\n        a: Output parameter.\n    \"\"\"\n    return a\n</code></pre>"},{"location":"doc-pages/auto-generated/docstrings/#pymesh.docstrings.test_fn_with_copied_docstring","title":"test_fn_with_copied_docstring","text":"<pre><code>test_fn_with_copied_docstring(a)\n</code></pre> <p>Dummy docstring, to be replaced.</p> Source code in <code>pymesh/docstrings.py</code> <pre><code>@copy_docstring(test_fn)\ndef test_fn_with_copied_docstring(a: Any) -&gt; Any:\n    \"\"\"Dummy docstring, to be replaced.\"\"\"\n    return a\n</code></pre>"},{"location":"doc-pages/auto-generated/exceptions/","title":"exceptions","text":"<p>Module with code for handling errors and exceptions.</p>"},{"location":"doc-pages/auto-generated/exceptions/#pymesh.exceptions.CurveIntersectionError","title":"CurveIntersectionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when curves in selection does not share intersection points</p> Source code in <code>pymesh/exceptions.py</code> <pre><code>class CurveIntersectionError(Exception):\n    \"\"\"Raised when curves in selection does not share intersection points\"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/typing/","title":"typing","text":""},{"location":"doc-pages/auto-generated/typing/#pymesh.typing.NDArray3","title":"NDArray3  <code>module-attribute</code>","text":"<pre><code>NDArray3 = Annotated[NDArray[DType], Literal[3]]\n</code></pre> <p>Numpy ndarray with shape (3, ).</p>"},{"location":"doc-pages/auto-generated/typing/#pymesh.typing.NDArray3xNxN","title":"NDArray3xNxN  <code>module-attribute</code>","text":"<pre><code>NDArray3xNxN = Annotated[NDArray[DType], Literal[3, 'N', 'N']]\n</code></pre> <p>Numpy ndarray with shape (3, N, N).</p>"},{"location":"doc-pages/auto-generated/utils/","title":"utils","text":"<p>Package utility functions.</p> Geometry helper functions <ul> <li>rotate_point_xyz</li> <li>mirror_point_xyz</li> </ul> Validation functions <ul> <li>validate_curve_path_parameters</li> <li>validate_surface_path_parameters</li> </ul> Benchmark functions <ul> <li>time_it</li> </ul>"},{"location":"doc-pages/auto-generated/utils/#pymesh.utils.time_it","title":"time_it","text":"<pre><code>time_it(func)\n</code></pre> <p>Wrapper function used to time function execution time</p> Source code in <code>pymesh/utils.py</code> <pre><code>def time_it(func):\n    \"\"\"Wrapper function used to time function execution time\"\"\"\n\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(\n            f\"Exceution of '{func.__name__}' took {round((end - start) * 1000)} mil sec.\"\n        )\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"doc-pages/auto-generated/utils/#pymesh.utils.rotate_point_xyz","title":"rotate_point_xyz","text":"<pre><code>rotate_point_xyz(x, y, z, angle, a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Rotates point around an axis.</p> <p>Implementation based on WikiPedia.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>int | float</code> <p>Angle in radians Poitive direction defined as counter-clockwise, based on the right-hand rule.</p> required <code>a</code> <code>int | float</code> <p>Axis vector x direction.</p> required <code>b</code> <code>int | float</code> <p>Axis vector y direction.</p> required <code>c</code> <code>int | float</code> <p>Axis vector z direction.</p> required <code>x0</code> <code>int | float</code> <p>Axis base x coordinate Default is origin of coordinate system.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Axis base y coordinate Default is origin of coordinate system.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Axis base z coordinate Default is origin of coordinate system.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>NDArray3</code> <p>Rotated point xyz coordinates given as a numpy array shaped (3,)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input value are not of type int or float.</p> Source code in <code>pymesh/utils.py</code> <pre><code>def rotate_point_xyz(\n    x: int | float,\n    y: int | float,\n    z: int | float,\n    angle: int | float,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; NDArray3:\n    \"\"\"Rotates point around an axis.\n\n    Implementation based on [WikiPedia](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n\n    Args:\n        angle (int | float): Angle in radians\n            Poitive direction defined as counter-clockwise,\n            based on the right-hand rule.\n        a (int | float): Axis vector x direction.\n        b (int | float): Axis vector y direction.\n        c (int | float): Axis vector z direction.\n        x0 (int | float, optional): Axis base x coordinate\n            Default is origin of coordinate system.\n        y0 (int | float, optional): Axis base y coordinate\n            Default is origin of coordinate system.\n        z0 (int | float, optional): Axis base z coordinate\n            Default is origin of coordinate system.\n\n    Returns:\n        (NDArray3): Rotated point xyz coordinates\n            given as a numpy array shaped (3,)\n\n    Raises:\n        TypeError: If input value are not of type int or float.\n    \"\"\"\n    for val in (x, y, z, angle, a, b, c, x0, y0, z0):\n        if not isinstance(val, (int, float)):\n            raise TypeError(f\"Expected {val!r} to be int or float\")\n    xyz = np.array([x, y, z])\n    xyz0 = np.array([x0, y0, z0])\n    abc = np.array([a, b, c])\n    avec = abc / math.sqrt(np.sum(abc**2))\n    pvec = xyz - xyz0\n    part1 = pvec * math.cos(angle)\n    part2 = np.cross(avec, pvec) * math.sin(angle)\n    part3 = avec * np.dot(avec, pvec) * (1 - math.cos(angle))\n    return xyz0 + part1 + part2 + part3\n</code></pre>"},{"location":"doc-pages/auto-generated/utils/#pymesh.utils.mirror_point_xyz","title":"mirror_point_xyz","text":"<pre><code>mirror_point_xyz(x, y, z, a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Mirrors xyz point in a plane.</p> <p>Implementation based on formulation by Jean Marie.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int | float</code> <p>Point x coordinate.</p> required <code>y</code> <code>int | float</code> <p>Point y coordinate.</p> required <code>z</code> <code>int | float</code> <p>Point z coordinate.</p> required <code>a</code> <code>int | float</code> <p>Plane normal vector x dimension.</p> required <code>b</code> <code>int | float</code> <p>Plane normal vector y dimension.</p> required <code>c</code> <code>int | float</code> <p>Plane normal vector z dimension.</p> required <code>x0</code> <code>int | float</code> <p>Plane normal vector base x coordinate Default is origin of coordinate system.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Plane normal vector base y coordinate Default is origin of coordinate system.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Plane normal vector base z coordinate Default is origin of coordinate system.</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>NDArray3</code> <code>NDArray3</code> <p>Rotated point xyz coordinates given as a numpy array shaped (3,)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input value are not of type int or float.</p> Source code in <code>pymesh/utils.py</code> <pre><code>def mirror_point_xyz(\n    x: int | float,\n    y: int | float,\n    z: int | float,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; NDArray3:\n    \"\"\"Mirrors xyz point in a plane.\n\n    Implementation based on formulation by [Jean Marie](https://math.stackexchange.com/questions/3927881/reflection-over-planes-in-3d).\n\n    Args:\n        x (int | float): Point x coordinate.\n        y (int | float): Point y coordinate.\n        z (int | float): Point z coordinate.\n        a (int | float): Plane normal vector x dimension.\n        b (int | float): Plane normal vector y dimension.\n        c (int | float): Plane normal vector z dimension.\n        x0 (int | float, optional): Plane normal vector base x coordinate\n            Default is origin of coordinate system.\n        y0 (int | float, optional): Plane normal vector base y coordinate\n            Default is origin of coordinate system.\n        z0 (int | float, optional): Plane normal vector base z coordinate\n            Default is origin of coordinate system.\n\n    Returns:\n        NDArray3: Rotated point xyz coordinates\n            given as a numpy array shaped (3,)\n\n    Raises:\n        TypeError: If input value are not of type int or float.\n    \"\"\"\n    for val in (x, y, z, a, b, c, x0, y0, z0):\n        if not isinstance(val, (int, float)):\n            raise TypeError(f\"Expected {val!r} to be int or float\")\n    xyz = np.array([x, y, z])\n    xyz0 = np.array([x0, y0, z0])\n    abc = np.array([a, b, c])\n    a, b, c = abc / math.sqrt(np.sum(abc**2))\n    transformation_matrix = np.array(\n        [\n            [1 - 2 * a * a, -2 * a * b, -2 * a * c],\n            [-2 * a * b, 1 - 2 * b * b, -2 * b * c],\n            [-2 * a * c, -2 * b * c, 1 - 2 * c * c],\n        ]\n    )\n    return transformation_matrix.dot(xyz - xyz0) + xyz0\n</code></pre>"},{"location":"doc-pages/auto-generated/utils/#pymesh.utils.validate_curve_path_parameters","title":"validate_curve_path_parameters","text":"<pre><code>validate_curve_path_parameters(u, flip=False)\n</code></pre> <p>Validates the normalized curve path parameter.</p> <p>Args: u (int | float): Normalized path parameter between 0 and 1. flip (bool, optional): Default if False. If True,     then u = (1 - u), i.e. the direction is flipped.</p> <p>Returns:</p> Name Type Description <code>u</code> <code>float</code> <p>Normalized path paremeter between 0 and 1.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If u is not of type int or float</p> <code>ValueError</code> <p>If u is not part of the number set [0 1].</p> Source code in <code>pymesh/utils.py</code> <pre><code>def validate_curve_path_parameters(u: int | float, flip: bool = False) -&gt; float:\n    \"\"\"Validates the normalized curve path parameter.\n\n    Args:\n    u (int | float): Normalized path parameter between 0 and 1.\n    flip (bool, optional): Default if False. If True,\n        then u = (1 - u), i.e. the direction is flipped.\n\n\n    Returns:\n        u (float): Normalized path paremeter between 0 and 1.\n\n    Raises:\n        TypeError: If u is not of type int or float\n        ValueError: If u is not part of the number set [0 1].\n    \"\"\"\n    if not isinstance(u, (int, float)):\n        raise TypeError(f\"Expected an int or float number, but got {u!r}\")\n    if isinstance(u, int):\n        u = float(u)\n    if u &lt; 0 or 1 &lt; u:\n        raise ValueError(f\"Expected a value between 0 and 1 but got {u!r}\")\n    if flip:\n        u = 1 - u\n    return u\n</code></pre>"},{"location":"doc-pages/auto-generated/utils/#pymesh.utils.validate_surface_path_parameters","title":"validate_surface_path_parameters","text":"<pre><code>validate_surface_path_parameters(u, w, uflip=False, wflip=False)\n</code></pre> <p>Validates the normalized surface path parameter.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>int | float</code> <p>Normalized path parameter between 0 and 1.</p> required <code>w</code> <code>int | float</code> <p>Normalized path parameter between 0 and 1.</p> required <code>uflip</code> <code>bool</code> <p>Default is False. If True, then u = (1 - u), i.e. the direction is flipped.</p> <code>False</code> <code>wflip</code> <code>bool</code> <p>Default is False. If True, then w = (1 - w), i.e. the direction is flipped.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple (u, w) with normalized parameters btween 0 and 1.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If u or w is not of type int or float</p> <code>ValueError</code> <p>If u or w is not part of the number set [0 1].</p> Source code in <code>pymesh/utils.py</code> <pre><code>def validate_surface_path_parameters(\n    u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n) -&gt; tuple[float, float]:\n    \"\"\"Validates the normalized surface path parameter.\n\n    Args:\n        u (int | float): Normalized path parameter between 0 and 1.\n        w (int | float): Normalized path parameter between 0 and 1.\n        uflip (bool, optional): Default is False. If True,\n            then u = (1 - u), i.e. the direction is flipped.\n        wflip (bool, optional): Default is False. If True,\n            then w = (1 - w), i.e. the direction is flipped.\n\n    Returns:\n        (tuple): Tuple (u, w) with normalized parameters btween 0 and 1.\n\n    Raises:\n        TypeError: If u or w is not of type int or float\n        ValueError: If u or w is not part of the number set [0 1].\n    \"\"\"\n    return (\n        validate_curve_path_parameters(u, uflip),\n        validate_curve_path_parameters(w, wflip),\n    )\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/","title":"geo","text":""},{"location":"doc-pages/auto-generated/geo/point/","title":"point","text":""},{"location":"doc-pages/auto-generated/geo/point/#pymesh.geo.point.Point","title":"Point","text":"<p>Point class with xyz coordinates in three-dimensional space.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>int | float</code> <p>Point x coordinate.</p> <code>y</code> <code>int | float</code> <p>Point y coordinate.</p> <code>z</code> <code>int | float</code> <p>Point z coordinate.</p> <code>xyz</code> <code>NDArray3[float]</code> <p>Numpy ndarray with x, y and z values. The numpy ndarray has shape (3,) with x at index 0, y at index 1 and z at index 2.</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>class Point:\n    \"\"\"Point class with xyz coordinates in three-dimensional space.\n\n    Attributes:\n        x (int | float): Point x coordinate.\n        y (int | float): Point y coordinate.\n        z (int | float): Point z coordinate.\n        xyz (NDArray3[float]): Numpy ndarray with x, y and z values.\n            The numpy ndarray has shape (3,) with x at index 0, y at\n            index 1 and z at index 2.\n    \"\"\"\n\n    x = AsNumber(return_type=float)\n    y = AsNumber(return_type=float)\n    z = AsNumber(return_type=float)\n\n    def __init__(self, x: int | float, y: int | float, z: int | float) -&gt; None:\n        \"\"\"Initialization method.\n\n        Args:\n            x: Point x coordinate.\n            y: Point y coordinate.\n            z: Point z coordinate.\n        \"\"\"\n        self.x, self.y, self.z = x, y, z\n\n    @property\n    def xyz(self) -&gt; NDArray3[np.float64]:\n        return np.array([self.x, self.y, self.z])\n\n    def __eq__(self, other) -&gt; bool:\n        DECIMALS = 10\n        return np.all(\n            np.round(self.xyz, decimals=DECIMALS)\n            == np.round(other.xyz, decimals=DECIMALS)\n        )\n\n    def __ne__(self, other: object) -&gt; bool:\n        return not self.__eq__(other)\n\n    def __add__(self, other):\n        return self.xyz + other.xyz\n\n    def __sub__(self, other):\n        return self.xyz - other.xyz\n\n    def __repr__(self):\n        return f\"{type(self).__name__}(x={self.x:.2f}, y={self.y:.2f}, z={self.z:.2f})\"\n\n    def copy(self) -&gt; Self:\n        \"\"\"Returns a copy of point instance\"\"\"\n        return Point(self.x, self.y, self.z)\n\n    def move(self, dx: int | float, dy: int | float, dz: int | float) -&gt; Self:\n        \"\"\"Moves the point coordinates in space.\n\n        Args:\n            dx: Distance moved in the x-direction.\n            dy: Distance moved in the y-direction.\n            dz: Distance moved in the z-direction.\n\n        Returns:\n            (Point): Point with updated xyz coordinates.\n        \"\"\"\n        for val in (dx, dy, dz):\n            if not isinstance(val, (int, float)):\n                raise TypeError(f\"Expected {val!r} to be an int or float\")\n        self.x += float(dx)\n        self.y += float(dy)\n        self.z += float(dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        \"\"\"Rotates point around an axis.\n\n        Parameters are passed to [pymesh.utils.rotate_point_xyz][].\n        \"\"\"\n        self.x, self.y, self.z = rotate_point_xyz(\n            self.x, self.y, self.z, angle, a, b, c, x0, y0, z0\n        )\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        \"\"\"Mirrors point in a plane.\n\n        Parameters are passed to [pymesh.utils.mirror_point_xyz][].\n        \"\"\"\n        self.x, self.y, self.z = mirror_point_xyz(\n            self.x, self.y, self.z, a, b, c, x0, y0, z0\n        )\n        return self\n\n    def get_distance_to(self, point: Self) -&gt; float:\n        \"\"\"Returns the shortest distance between point instance and another point\n\n        Args:\n            point: Other point from which the distance is calculated.\n\n        Returns:\n            (float): Direct distance between this and other point.\n\n        Raises:\n            TypeError: If point is not of type Self.\n        \"\"\"\n        if not isinstance(point, Point):\n            raise TypeError(f\"point must be of type '{Point.__name__}'.\")\n        dx = self.x - point.x\n        dy = self.y - point.y\n        dz = self.z - point.z\n        return math.sqrt(dx**2 + dy**2 + dz**2)\n\n    def create_relative_point(\n        self, dx: int | float = 0, dy: int | float = 0, dz: int | float = 0\n    ) -&gt; Self:\n        \"\"\"Creates a new point using relative positional arguments.\n\n        Args:\n            dx: Relative x coordinate.\n            dy: Relative y coordinate.\n            dz: Relative z coordinate.\n\n        Returns:\n            (Point): New point based on relative coordinates.\n\n        Raises:\n            TypeError: If dx, dy or dz are not of type int or float.\n            ValueError: If both dx, dy and dz are equal to zero.\n        \"\"\"\n        for value in (dx, dy, dz):\n            if not isinstance(value, (int, float)):\n                raise TypeError(\"Relative position must be of type 'float' or 'int'\")\n        if (dx == 0.0) and (dy == 0.0) and (dz == 0.0):\n            raise ValueError(\"A non-zero relative position must be given\")\n        x = self.x + float(dx)\n        y = self.y + float(dy)\n        z = self.z + float(dz)\n        return Point(x, y, z)\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/point/#pymesh.geo.point.Point.__init__","title":"__init__","text":"<pre><code>__init__(x, y, z)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int | float</code> <p>Point x coordinate.</p> required <code>y</code> <code>int | float</code> <p>Point y coordinate.</p> required <code>z</code> <code>int | float</code> <p>Point z coordinate.</p> required Source code in <code>pymesh/geo/point.py</code> <pre><code>def __init__(self, x: int | float, y: int | float, z: int | float) -&gt; None:\n    \"\"\"Initialization method.\n\n    Args:\n        x: Point x coordinate.\n        y: Point y coordinate.\n        z: Point z coordinate.\n    \"\"\"\n    self.x, self.y, self.z = x, y, z\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/point/#pymesh.geo.point.Point.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of point instance</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Returns a copy of point instance\"\"\"\n    return Point(self.x, self.y, self.z)\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/point/#pymesh.geo.point.Point.move","title":"move","text":"<pre><code>move(dx, dy, dz)\n</code></pre> <p>Moves the point coordinates in space.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>int | float</code> <p>Distance moved in the x-direction.</p> required <code>dy</code> <code>int | float</code> <p>Distance moved in the y-direction.</p> required <code>dz</code> <code>int | float</code> <p>Distance moved in the z-direction.</p> required <p>Returns:</p> Type Description <code>Point</code> <p>Point with updated xyz coordinates.</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>def move(self, dx: int | float, dy: int | float, dz: int | float) -&gt; Self:\n    \"\"\"Moves the point coordinates in space.\n\n    Args:\n        dx: Distance moved in the x-direction.\n        dy: Distance moved in the y-direction.\n        dz: Distance moved in the z-direction.\n\n    Returns:\n        (Point): Point with updated xyz coordinates.\n    \"\"\"\n    for val in (dx, dy, dz):\n        if not isinstance(val, (int, float)):\n            raise TypeError(f\"Expected {val!r} to be an int or float\")\n    self.x += float(dx)\n    self.y += float(dy)\n    self.z += float(dz)\n    return self\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/point/#pymesh.geo.point.Point.rotate","title":"rotate","text":"<pre><code>rotate(angle, a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Rotates point around an axis.</p> <p>Parameters are passed to pymesh.utils.rotate_point_xyz.</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>def rotate(\n    self,\n    angle: int | float,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; Self:\n    \"\"\"Rotates point around an axis.\n\n    Parameters are passed to [pymesh.utils.rotate_point_xyz][].\n    \"\"\"\n    self.x, self.y, self.z = rotate_point_xyz(\n        self.x, self.y, self.z, angle, a, b, c, x0, y0, z0\n    )\n    return self\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/point/#pymesh.geo.point.Point.mirror","title":"mirror","text":"<pre><code>mirror(a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Mirrors point in a plane.</p> <p>Parameters are passed to pymesh.utils.mirror_point_xyz.</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>def mirror(\n    self,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; Self:\n    \"\"\"Mirrors point in a plane.\n\n    Parameters are passed to [pymesh.utils.mirror_point_xyz][].\n    \"\"\"\n    self.x, self.y, self.z = mirror_point_xyz(\n        self.x, self.y, self.z, a, b, c, x0, y0, z0\n    )\n    return self\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/point/#pymesh.geo.point.Point.get_distance_to","title":"get_distance_to","text":"<pre><code>get_distance_to(point)\n</code></pre> <p>Returns the shortest distance between point instance and another point</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Self</code> <p>Other point from which the distance is calculated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Direct distance between this and other point.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If point is not of type Self.</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>def get_distance_to(self, point: Self) -&gt; float:\n    \"\"\"Returns the shortest distance between point instance and another point\n\n    Args:\n        point: Other point from which the distance is calculated.\n\n    Returns:\n        (float): Direct distance between this and other point.\n\n    Raises:\n        TypeError: If point is not of type Self.\n    \"\"\"\n    if not isinstance(point, Point):\n        raise TypeError(f\"point must be of type '{Point.__name__}'.\")\n    dx = self.x - point.x\n    dy = self.y - point.y\n    dz = self.z - point.z\n    return math.sqrt(dx**2 + dy**2 + dz**2)\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/point/#pymesh.geo.point.Point.create_relative_point","title":"create_relative_point","text":"<pre><code>create_relative_point(dx=0, dy=0, dz=0)\n</code></pre> <p>Creates a new point using relative positional arguments.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>int | float</code> <p>Relative x coordinate.</p> <code>0</code> <code>dy</code> <code>int | float</code> <p>Relative y coordinate.</p> <code>0</code> <code>dz</code> <code>int | float</code> <p>Relative z coordinate.</p> <code>0</code> <p>Returns:</p> Type Description <code>Point</code> <p>New point based on relative coordinates.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If dx, dy or dz are not of type int or float.</p> <code>ValueError</code> <p>If both dx, dy and dz are equal to zero.</p> Source code in <code>pymesh/geo/point.py</code> <pre><code>def create_relative_point(\n    self, dx: int | float = 0, dy: int | float = 0, dz: int | float = 0\n) -&gt; Self:\n    \"\"\"Creates a new point using relative positional arguments.\n\n    Args:\n        dx: Relative x coordinate.\n        dy: Relative y coordinate.\n        dz: Relative z coordinate.\n\n    Returns:\n        (Point): New point based on relative coordinates.\n\n    Raises:\n        TypeError: If dx, dy or dz are not of type int or float.\n        ValueError: If both dx, dy and dz are equal to zero.\n    \"\"\"\n    for value in (dx, dy, dz):\n        if not isinstance(value, (int, float)):\n            raise TypeError(\"Relative position must be of type 'float' or 'int'\")\n    if (dx == 0.0) and (dy == 0.0) and (dz == 0.0):\n        raise ValueError(\"A non-zero relative position must be given\")\n    x = self.x + float(dx)\n    y = self.y + float(dy)\n    z = self.z + float(dz)\n    return Point(x, y, z)\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/","title":"curves","text":""},{"location":"doc-pages/auto-generated/geo/curves/arc3p/","title":"arc3p","text":"<p>Module containing the Arc3P class</p>"},{"location":"doc-pages/auto-generated/geo/curves/arc3p/#pymesh.geo.curves.arc3p.Arc3P","title":"Arc3P","text":"<p>               Bases: <code>Curve</code></p> <p>Creates an arc curve object, generated from three points in space.</p> <p>Implementation based on WikiPedia. For more information, see Curve documentation.</p> <p>Parameters:</p> Name Type Description Default <code>centre</code> <code>Point</code> <p>Arc center point</p> required <code>inverse_sector</code> <code>bool</code> <p>Specifies if to use the outer (True) or inner (False) sector of the swept circle. Defaults to False.</p> <code>False</code> Source code in <code>pymesh/geo/curves/arc3p.py</code> <pre><code>class Arc3P(Curve):\n    \"\"\"Creates an arc curve object, generated from three points in space.\n\n    Implementation based on [WikiPedia](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n    For more information, see Curve documentation.\n\n    Args:\n        centre (Point): Arc center point\n        inverse_sector (bool): Specifies if to use the outer\n            (True) or inner (False) sector of the swept circle.\n            Defaults to False.\n    \"\"\"\n\n    centre = AsInstanceOf(Point)\n    inverse_sector = AsInstanceOf(bool)\n\n    def __init__(\n        self,\n        centre: Point,\n        start: Point,\n        end: Point,\n        inverse_sector: bool = False,\n    ):\n        \"\"\"Initialization method.\n\n        Args:\n            centre: Arc center point\n            start: Arc start point\n            end: Arc end point\n            inverse_sector: Specifies if to use the outer (True)\n                or inner (False) sector of the swept circle.\n                Defaults to False.\n\n        Raises:\n            ValueError: If the start and end points are located\n                at different radii from the centre point.\n            ValueError: If cross product of the centre-to-start\n                and centre-to-end vectors is zero.\n        \"\"\"\n        self.centre = centre\n        self.start = start\n        self.end = end\n        self.inverse_sector = inverse_sector\n        validate_radii_and_cross_product(centre, start, end)\n\n    def __eq__(self, other):\n        return (\n            self.centre == other.centre\n            and self.start == other.start\n            and self.end == other.end\n        )\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __repr__(self):\n        cls = type(self).__name__\n        c, s, e, i = self.centre, self.start, self.end, self.inverse_sector\n        return f\"{cls}(centre={c}, start={s}, end={e}, inverse_sector={i})\"\n\n    def copy(self) -&gt; Self:\n        return Arc3P(\n            self.centre.copy(), self.start.copy(), self.end.copy(), self.inverse_sector\n        )\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.centre.move(dx, dy, dz)\n        self.start.move(dx, dy, dz)\n        self.end.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.centre.rotate(angle, a, b, c, x0, y0, z0)\n        self.start.rotate(angle, a, b, c, x0, y0, z0)\n        self.end.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.centre.mirror(a, b, c, x0, y0, z0)\n        self.start.mirror(a, b, c, x0, y0, z0)\n        self.end.mirror(a, b, c, x0, y0, z0)\n        return self\n\n    @property\n    def radius(self) -&gt; float:\n        return np.sqrt(np.sum((self.start - self.centre) ** 2))\n\n    @property\n    def cross_product(self) -&gt; NDArray3[np.float64]:\n        sign = -1 if self.inverse_sector else 1\n        return sign * np.cross((self.start - self.centre), (self.end - self.centre))\n\n    @property\n    def plane_unit_normal(self) -&gt; NDArray3[np.float64]:\n        return self.cross_product / np.sqrt(np.sum(self.cross_product**2))\n\n    @property\n    def angle(self) -&gt; float:\n        angle = np.arccos(\n            np.dot((self.start - self.centre), (self.end - self.centre))\n            / (self.radius**2)\n        )\n        angle = 2 * math.pi - angle if self.inverse_sector else angle\n        return angle\n\n    @property\n    def length(self) -&gt; float:\n        return self.radius * self.angle\n\n    def path(self, u: int | float, flip: bool = False) -&gt; NDArray3[np.float64]:\n        u = validate_curve_path_parameters(u, flip)\n        v, k, a = (self.start - self.centre), self.plane_unit_normal, self.angle\n        xyz0 = self.centre.xyz\n        part1 = v * math.cos(a * u)\n        part2 = np.cross(k, v) * math.sin(a * u)\n        part3 = k * np.dot(k, v) * (1 - math.cos(a * u))\n        return xyz0 + part1 + part2 + part3\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/arc3p/#pymesh.geo.curves.arc3p.Arc3P.__init__","title":"__init__","text":"<pre><code>__init__(centre, start, end, inverse_sector=False)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>centre</code> <code>Point</code> <p>Arc center point</p> required <code>start</code> <code>Point</code> <p>Arc start point</p> required <code>end</code> <code>Point</code> <p>Arc end point</p> required <code>inverse_sector</code> <code>bool</code> <p>Specifies if to use the outer (True) or inner (False) sector of the swept circle. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the start and end points are located at different radii from the centre point.</p> <code>ValueError</code> <p>If cross product of the centre-to-start and centre-to-end vectors is zero.</p> Source code in <code>pymesh/geo/curves/arc3p.py</code> <pre><code>def __init__(\n    self,\n    centre: Point,\n    start: Point,\n    end: Point,\n    inverse_sector: bool = False,\n):\n    \"\"\"Initialization method.\n\n    Args:\n        centre: Arc center point\n        start: Arc start point\n        end: Arc end point\n        inverse_sector: Specifies if to use the outer (True)\n            or inner (False) sector of the swept circle.\n            Defaults to False.\n\n    Raises:\n        ValueError: If the start and end points are located\n            at different radii from the centre point.\n        ValueError: If cross product of the centre-to-start\n            and centre-to-end vectors is zero.\n    \"\"\"\n    self.centre = centre\n    self.start = start\n    self.end = end\n    self.inverse_sector = inverse_sector\n    validate_radii_and_cross_product(centre, start, end)\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/arcpva/","title":"arcpva","text":"<p>Module containing the ArcPVA class</p>"},{"location":"doc-pages/auto-generated/geo/curves/arcpva/#pymesh.geo.curves.arcpva.ArcPVA","title":"ArcPVA","text":"<p>               Bases: <code>Curve</code></p> <p>Creates a circular arc based on a point, a vector axis of rotation and an angle.</p> <p>Attributes:</p> Name Type Description <code>angle</code> <code>int | float</code> <p>Angle in radians. Positive direction defined as counter-clockwise, based on the right-hand rule.</p> <code>a</code> <code>int | float</code> <p>Axis vector x direction.</p> <code>b</code> <code>int | float</code> <p>Axis vector y direction.</p> <code>c</code> <code>int | float</code> <p>Axis vector z direction.</p> <code>x0</code> <code>int | float</code> <p>Axis base x coordinate, default is zero.</p> <code>y0</code> <code>int | float</code> <p>Axis base y coordinate, default is zero.</p> <code>z0</code> <code>int | float</code> <p>Axis base z coordinate, default is zero.</p> Source code in <code>pymesh/geo/curves/arcpva.py</code> <pre><code>class ArcPVA(Curve):\n    \"\"\"Creates a circular arc based on a point, a vector axis of rotation and an angle.\n\n    Attributes:\n        angle (int | float): Angle in radians.\n            Positive direction defined as counter-clockwise, based on the right-hand rule.\n        a (int | float): Axis vector x direction.\n        b (int | float): Axis vector y direction.\n        c (int | float): Axis vector z direction.\n        x0 (int | float): Axis base x coordinate, default is zero.\n        y0 (int | float): Axis base y coordinate, default is zero.\n        z0 (int | float): Axis base z coordinate, default is zero.\n    \"\"\"\n\n    angle = AsNumber(return_type=float)\n    a = AsNumber(return_type=float)\n    b = AsNumber(return_type=float)\n    c = AsNumber(return_type=float)\n    x0 = AsNumber(return_type=float)\n    y0 = AsNumber(return_type=float)\n    z0 = AsNumber(return_type=float)\n\n    def __init__(\n        self,\n        start: Point,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ):\n        \"\"\"Initialization method.\n\n        Args:\n            start: Point being rotated around the vector.\n            angle: Angle in radians.\n                Positive direction defined as counter-clockwise, based on the right-hand rule.\n            a: Axis vector x direction.\n            b: Axis vector y direction.\n            c: Axis vector z direction.\n            x0: Axis base x coordinate, default is zero.\n            y0: Axis base y coordinate, default is zero.\n            z0: Axis base z coordinate, default is zero.\n        \"\"\"\n        self.start = start\n        self.angle = angle\n        self.a = a\n        self.b = b\n        self.c = c\n        self.x0 = x0\n        self.y0 = y0\n        self.z0 = z0\n\n    @property\n    def end(self) -&gt; NDArray3[np.float64]:\n        x, y, z = self.path(1)\n        return Point(x, y, z)\n\n    def __eq__(self, other):\n        DECIMALS = 10\n        is_equal = True\n        for u in np.linspace(0, 1, num=100, endpoint=True):\n            u_self = np.all(np.round(self.path(u), decimals=DECIMALS))\n            u_other = np.all(np.round(other.path(u), decimals=DECIMALS))\n            if u_self != u_other:\n                is_equal = False\n                break\n        return is_equal\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __repr__(self):\n        cls = type(self).__name__\n        txt = (\n            f\"{cls}(start={self.start!r}, angle={self.angle:.2f}, \"\n            f\"a={self.a:.2f}, b={self.b:.2f}, c={self.c:.2f}, \"\n            f\"x0={self.x0:.2f}, y0={self.y0:.2f}, z0={self.z0:.2f})\"\n        )\n        return txt\n\n    @property\n    def radius(self) -&gt; float:\n        \"\"\"Returns the arc radius.\"\"\"\n        xyz0 = np.array([self.x0, self.y0, self.z0])\n        a = self.start.xyz - xyz0\n        b = np.array([self.a, self.b, self.c])\n        r = a - np.dot(a, b) / np.dot(b, b) * b\n        return np.sqrt(np.sum(r**2))\n\n    @property\n    def length(self) -&gt; float:\n        return self.radius * self.angle\n\n    def path(self, u: int | float, flip: bool = False) -&gt; NDArray3[np.float64]:\n        u = validate_curve_path_parameters(u, flip)\n        angle = self.angle\n        xyz0 = np.array([self.x0, self.y0, self.z0])\n        abc = np.array([self.a, self.b, self.c])\n        pvec = self.start.xyz - xyz0\n        part1 = pvec * math.cos(angle * u)\n        part2 = np.cross(abc, pvec) * math.sin(angle * u)\n        part3 = abc * np.dot(abc, pvec) * (1 - math.cos(angle * u))\n        return xyz0 + part1 + part2 + part3\n\n    def copy(self) -&gt; Self:\n        return ArcPVA(\n            self.start.copy(),\n            self.angle,\n            self.a,\n            self.b,\n            self.c,\n            self.x0,\n            self.y0,\n            self.z0,\n        )\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.start.move(dx, dy, dz)  # also validates input\n        self.x0 += float(dx)\n        self.y0 += float(dy)\n        self.z0 += float(dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.start.rotate(angle, a, b, c, x0, y0, z0)  # also validates input\n        xyz0 = np.array([self.x0, self.y0, self.z0])\n        xyz0_rotated = rotate_point_xyz(\n            xyz0[0], xyz0[1], xyz0[2], angle, a, b, c, x0, y0, z0\n        )\n        xyz1_rotated = rotate_point_xyz(\n            self.a + x0, self.b + y0, self.c + z0, angle, a, b, c, x0, y0, z0\n        )\n        self.x0, self.y0, self.z0 = xyz0_rotated\n        self.a, self.b, self.c = xyz1_rotated - xyz0\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.start.mirror(a, b, c, x0, y0, z0)  # validates input, should be first\n        xyz0 = np.array([self.x0, self.y0, self.z0])\n        xyz0_mirrored = mirror_point_xyz(xyz0[0], xyz0[1], xyz0[2], a, b, c, x0, y0, z0)\n        xyz1_mirrored = mirror_point_xyz(\n            self.a + x0, self.b + y0, self.c + z0, a, b, c, x0, y0, z0\n        )\n        self.x0, self.y0, self.z0 = xyz0_mirrored\n        self.a, self.b, self.c = xyz1_mirrored - xyz0\n        return self\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/arcpva/#pymesh.geo.curves.arcpva.ArcPVA.radius","title":"radius  <code>property</code>","text":"<pre><code>radius\n</code></pre> <p>Returns the arc radius.</p>"},{"location":"doc-pages/auto-generated/geo/curves/arcpva/#pymesh.geo.curves.arcpva.ArcPVA.__init__","title":"__init__","text":"<pre><code>__init__(start, angle, a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Point</code> <p>Point being rotated around the vector.</p> required <code>angle</code> <code>int | float</code> <p>Angle in radians. Positive direction defined as counter-clockwise, based on the right-hand rule.</p> required <code>a</code> <code>int | float</code> <p>Axis vector x direction.</p> required <code>b</code> <code>int | float</code> <p>Axis vector y direction.</p> required <code>c</code> <code>int | float</code> <p>Axis vector z direction.</p> required <code>x0</code> <code>int | float</code> <p>Axis base x coordinate, default is zero.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Axis base y coordinate, default is zero.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Axis base z coordinate, default is zero.</p> <code>0.0</code> Source code in <code>pymesh/geo/curves/arcpva.py</code> <pre><code>def __init__(\n    self,\n    start: Point,\n    angle: int | float,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n):\n    \"\"\"Initialization method.\n\n    Args:\n        start: Point being rotated around the vector.\n        angle: Angle in radians.\n            Positive direction defined as counter-clockwise, based on the right-hand rule.\n        a: Axis vector x direction.\n        b: Axis vector y direction.\n        c: Axis vector z direction.\n        x0: Axis base x coordinate, default is zero.\n        y0: Axis base y coordinate, default is zero.\n        z0: Axis base z coordinate, default is zero.\n    \"\"\"\n    self.start = start\n    self.angle = angle\n    self.a = a\n    self.b = b\n    self.c = c\n    self.x0 = x0\n    self.y0 = y0\n    self.z0 = z0\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/bezier/","title":"bezier","text":"<p>Module containing the Bezier class</p>"},{"location":"doc-pages/auto-generated/geo/curves/bezier/#pymesh.geo.curves.bezier.Bezier","title":"Bezier","text":"<p>               Bases: <code>Curve</code></p> <p>Creates a bezier curve from a collection of three-dimensional points.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>list[Point] | tuple[Point]</code> <p>List or tuple of points.</p> Source code in <code>pymesh/geo/curves/bezier.py</code> <pre><code>class Bezier(Curve):\n    \"\"\"Creates a bezier curve from a collection of three-dimensional points.\n\n    Attributes:\n        points (list[Point] | tuple[Point]): List or tuple of points.\n    \"\"\"\n\n    points = AsContainerOf(tuple, Point, min_length=2)\n\n    def __init__(self, points: list[Point] | tuple[Point]):\n        \"\"\"Initialization method.\n\n        Args:\n            points: List or tuple of points.\n\n        Raises:\n            TypeError: If points is not a list or tuple\n            ValueError: If points has less than two elements.\n            TypeError: If elements of points are not of type Point.\n        \"\"\"\n        if not isinstance(points, (tuple, list)):\n            raise TypeError(f\"{points!r} is not a tuple or list\")\n        self.points = tuple(points)\n\n    def __eq__(self, other):\n        is_equal = True\n        if type(self).__name__ != type(other).__name__:\n            is_equal = False\n        else:\n            for p1, p2 in zip(self.points, other.points):\n                if p1 != p2:\n                    is_equal = False\n                    break\n        return is_equal\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __repr__(self):\n        txt = f\"{type(self).__name__}(points=[\"\n        for i, point in enumerate(self.points):\n            ext = \", \" if i &lt; len(self.points) - 1 else \"])\"\n            txt += f\"{point!r}{ext}\"\n        return txt\n\n    @property\n    def start(self) -&gt; NDArray3[np.float64]:\n        x, y, z = self.path(0)\n        return Point(x, y, z)\n\n    @property\n    def end(self) -&gt; NDArray3[np.float64]:\n        x, y, z = self.path(1)\n        return Point(x, y, z)\n\n    @property\n    def length(self) -&gt; float:\n        distance = 0.0\n        xyz0 = self.path(0)\n        for u in np.linspace(start=0, stop=1, num=NUM_POINTS, endpoint=True):\n            xyz1 = self.path(u)\n            distance += np.sqrt(np.sum((xyz1 - xyz0) ** 2))\n            xyz0 = xyz1\n        return distance\n\n    def path(self, u: int | float, flip: bool = False) -&gt; NDArray3[np.float64]:\n        u = validate_curve_path_parameters(u, flip)\n\n        def bezier(points, t):\n            \"\"\"Recursive bezier curve definition.\n\n            Based on https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Constructing_B%C3%A9zier_curves\n            \"\"\"\n            if len(points) == 1:\n                return points[0].xyz\n            return (1 - t) * bezier(points[0:-1], t) + t * bezier(points[1:], t)\n\n        return bezier(self.points, u)\n\n    def copy(self) -&gt; Self:\n        points = []\n        for point in self.points:\n            points.append(point.copy())\n        return Bezier(points)\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        for point in self.points:\n            point.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        for point in self.points:\n            point.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        for point in self.points:\n            point.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/bezier/#pymesh.geo.curves.bezier.Bezier.__init__","title":"__init__","text":"<pre><code>__init__(points)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Point] | tuple[Point]</code> <p>List or tuple of points.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If points is not a list or tuple</p> <code>ValueError</code> <p>If points has less than two elements.</p> <code>TypeError</code> <p>If elements of points are not of type Point.</p> Source code in <code>pymesh/geo/curves/bezier.py</code> <pre><code>def __init__(self, points: list[Point] | tuple[Point]):\n    \"\"\"Initialization method.\n\n    Args:\n        points: List or tuple of points.\n\n    Raises:\n        TypeError: If points is not a list or tuple\n        ValueError: If points has less than two elements.\n        TypeError: If elements of points are not of type Point.\n    \"\"\"\n    if not isinstance(points, (tuple, list)):\n        raise TypeError(f\"{points!r} is not a tuple or list\")\n    self.points = tuple(points)\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/curve/","title":"curve","text":""},{"location":"doc-pages/auto-generated/geo/curves/curve/#pymesh.geo.curves.curve.Curve","title":"Curve","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class used which all curve classes inherit from.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>Point</code> <p>Curve starting point.</p> <code>end</code> <code>Point</code> <p>Curve ending point.</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>class Curve(ABC):\n    \"\"\"Abstract base class used which all curve classes inherit from.\n\n    Attributes:\n        start (Point): Curve starting point.\n        end (Point): Curve ending point.\n    \"\"\"\n\n    start = AsInstanceOf(Point)\n    \"\"\"Curve starting point.\"\"\"\n\n    end = AsInstanceOf(Point)\n    \"\"\"Curve ending point.\"\"\"\n\n    @abstractmethod\n    def copy(self) -&gt; Self:\n        \"\"\"Returns a recursive copy of curve instance.\"\"\"\n\n    @abstractmethod\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        \"\"\"Moves the curve a given relative position in space.\n\n        Args:\n            dx: Distance moved in the x-direction.\n            dy: Distance moved in the y-direction.\n            dz: Distance moved in the z-direction.\n\n        Returns:\n            (Curve): Curve with updated xyz coordinates.\n\n        Raises:\n            TypeError: If dx, dy or dz are not of type int or float.\n            ValueError: If dx, dy and dz are all zero.\n        \"\"\"\n\n    @abstractmethod\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        \"\"\"Rotates curve around an axis.\n\n        Implementation based on [WikiPedia](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n\n        Args:\n            angle: Angle in radians.\n                Poitive direction defined as counter-clockwise, based on the right-hand rule.\n            a: Axis vector x direction.\n            b: Axis vector y direction.\n            c: Axis vector z direction.\n            x0: Axis base x coordinate\n                Default is zero.\n            y0: Axis base y coordinate\n                Default is zero.\n            z0: Axis base z coordinate\n                Default is zero.\n\n        Returns:\n            (Curve): Rotated curve instance.\n\n        Raises:\n            TypeError: If input value are not of type int or float.\n        \"\"\"\n\n    @abstractmethod\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        \"\"\"Mirrors curve in a plane.\n\n        Plane is defined by a plane normal vector (a, b, c) and a point (x0, y0, z0) in the plane.\n        Implementation based on formulation by [Jean Marie](https://math.stackexchange.com/questions/3927881/reflection-over-planes-in-3d).\n\n        Args:\n            a: Plane normal vector x dimension.\n            b: Plane normal vector y dimension.\n            c: Plane normal vector z dimension.\n            x0: Plane normal vector base x coordinate\n                Default is origin of coordinate system.\n            y0: Plane normal vector base y coordinate\n                Default is origin of coordinate system.\n            z0: Plane normal vector base z coordinate\n                Default is origin of coordinate system.\n\n        Returns: Mirrored curve instance.\n\n        Raises:\n            TypeError: If input value are not of type int or float.\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def length(self) -&gt; float:\n        \"\"\"Returns the curve path length\"\"\"\n\n    @abstractmethod\n    def path(self, u: int | float, flip: bool = False) -&gt; NDArray3[np.float64]:\n        \"\"\"Curve path function that converts a normalized input u to a physical xyz point in space.\n\n        Args:\n            u: Normalized path parameter between 0 and 1,\n                where 0 and 1 represents the start and end locations, respectively.\n            flip: Bool specifying if path direction is flipped.\n                If True then u = (1 - u), i.e. the direction is flipped. Defaults\n                to False.\n\n        Returns:\n            (NDArray3): Numpy ndarray with shape (3,)\n\n        Raises:\n            TypeError: If u is not of type int or float.\n            ValueError: If u is not part of the number set [0 1].\n        \"\"\"\n\n    def get_path(self) -&gt; Callable[[int | float, bool], NDArray3[np.float64]]:\n        \"\"\"Returns curve path function\"\"\"\n        return self.path\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/curve/#pymesh.geo.curves.curve.Curve.start","title":"start  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start = AsInstanceOf(Point)\n</code></pre> <p>Curve starting point.</p>"},{"location":"doc-pages/auto-generated/geo/curves/curve/#pymesh.geo.curves.curve.Curve.end","title":"end  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end = AsInstanceOf(Point)\n</code></pre> <p>Curve ending point.</p>"},{"location":"doc-pages/auto-generated/geo/curves/curve/#pymesh.geo.curves.curve.Curve.length","title":"length  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>length\n</code></pre> <p>Returns the curve path length</p>"},{"location":"doc-pages/auto-generated/geo/curves/curve/#pymesh.geo.curves.curve.Curve.copy","title":"copy  <code>abstractmethod</code>","text":"<pre><code>copy()\n</code></pre> <p>Returns a recursive copy of curve instance.</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>@abstractmethod\ndef copy(self) -&gt; Self:\n    \"\"\"Returns a recursive copy of curve instance.\"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/curve/#pymesh.geo.curves.curve.Curve.move","title":"move  <code>abstractmethod</code>","text":"<pre><code>move(dx=0.0, dy=0.0, dz=0.0)\n</code></pre> <p>Moves the curve a given relative position in space.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>int | float</code> <p>Distance moved in the x-direction.</p> <code>0.0</code> <code>dy</code> <code>int | float</code> <p>Distance moved in the y-direction.</p> <code>0.0</code> <code>dz</code> <code>int | float</code> <p>Distance moved in the z-direction.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Curve</code> <p>Curve with updated xyz coordinates.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If dx, dy or dz are not of type int or float.</p> <code>ValueError</code> <p>If dx, dy and dz are all zero.</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>@abstractmethod\ndef move(\n    self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n) -&gt; Self:\n    \"\"\"Moves the curve a given relative position in space.\n\n    Args:\n        dx: Distance moved in the x-direction.\n        dy: Distance moved in the y-direction.\n        dz: Distance moved in the z-direction.\n\n    Returns:\n        (Curve): Curve with updated xyz coordinates.\n\n    Raises:\n        TypeError: If dx, dy or dz are not of type int or float.\n        ValueError: If dx, dy and dz are all zero.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/curve/#pymesh.geo.curves.curve.Curve.rotate","title":"rotate  <code>abstractmethod</code>","text":"<pre><code>rotate(angle, a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Rotates curve around an axis.</p> <p>Implementation based on WikiPedia.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>int | float</code> <p>Angle in radians. Poitive direction defined as counter-clockwise, based on the right-hand rule.</p> required <code>a</code> <code>int | float</code> <p>Axis vector x direction.</p> required <code>b</code> <code>int | float</code> <p>Axis vector y direction.</p> required <code>c</code> <code>int | float</code> <p>Axis vector z direction.</p> required <code>x0</code> <code>int | float</code> <p>Axis base x coordinate Default is zero.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Axis base y coordinate Default is zero.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Axis base z coordinate Default is zero.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Curve</code> <p>Rotated curve instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input value are not of type int or float.</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>@abstractmethod\ndef rotate(\n    self,\n    angle: int | float,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; Self:\n    \"\"\"Rotates curve around an axis.\n\n    Implementation based on [WikiPedia](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n\n    Args:\n        angle: Angle in radians.\n            Poitive direction defined as counter-clockwise, based on the right-hand rule.\n        a: Axis vector x direction.\n        b: Axis vector y direction.\n        c: Axis vector z direction.\n        x0: Axis base x coordinate\n            Default is zero.\n        y0: Axis base y coordinate\n            Default is zero.\n        z0: Axis base z coordinate\n            Default is zero.\n\n    Returns:\n        (Curve): Rotated curve instance.\n\n    Raises:\n        TypeError: If input value are not of type int or float.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/curve/#pymesh.geo.curves.curve.Curve.mirror","title":"mirror  <code>abstractmethod</code>","text":"<pre><code>mirror(a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Mirrors curve in a plane.</p> <p>Plane is defined by a plane normal vector (a, b, c) and a point (x0, y0, z0) in the plane. Implementation based on formulation by Jean Marie.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | float</code> <p>Plane normal vector x dimension.</p> required <code>b</code> <code>int | float</code> <p>Plane normal vector y dimension.</p> required <code>c</code> <code>int | float</code> <p>Plane normal vector z dimension.</p> required <code>x0</code> <code>int | float</code> <p>Plane normal vector base x coordinate Default is origin of coordinate system.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Plane normal vector base y coordinate Default is origin of coordinate system.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Plane normal vector base z coordinate Default is origin of coordinate system.</p> <code>0.0</code> <p>Returns: Mirrored curve instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input value are not of type int or float.</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>@abstractmethod\ndef mirror(\n    self,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; Self:\n    \"\"\"Mirrors curve in a plane.\n\n    Plane is defined by a plane normal vector (a, b, c) and a point (x0, y0, z0) in the plane.\n    Implementation based on formulation by [Jean Marie](https://math.stackexchange.com/questions/3927881/reflection-over-planes-in-3d).\n\n    Args:\n        a: Plane normal vector x dimension.\n        b: Plane normal vector y dimension.\n        c: Plane normal vector z dimension.\n        x0: Plane normal vector base x coordinate\n            Default is origin of coordinate system.\n        y0: Plane normal vector base y coordinate\n            Default is origin of coordinate system.\n        z0: Plane normal vector base z coordinate\n            Default is origin of coordinate system.\n\n    Returns: Mirrored curve instance.\n\n    Raises:\n        TypeError: If input value are not of type int or float.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/curve/#pymesh.geo.curves.curve.Curve.path","title":"path  <code>abstractmethod</code>","text":"<pre><code>path(u, flip=False)\n</code></pre> <p>Curve path function that converts a normalized input u to a physical xyz point in space.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>int | float</code> <p>Normalized path parameter between 0 and 1, where 0 and 1 represents the start and end locations, respectively.</p> required <code>flip</code> <code>bool</code> <p>Bool specifying if path direction is flipped. If True then u = (1 - u), i.e. the direction is flipped. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>NDArray3</code> <p>Numpy ndarray with shape (3,)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If u is not of type int or float.</p> <code>ValueError</code> <p>If u is not part of the number set [0 1].</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>@abstractmethod\ndef path(self, u: int | float, flip: bool = False) -&gt; NDArray3[np.float64]:\n    \"\"\"Curve path function that converts a normalized input u to a physical xyz point in space.\n\n    Args:\n        u: Normalized path parameter between 0 and 1,\n            where 0 and 1 represents the start and end locations, respectively.\n        flip: Bool specifying if path direction is flipped.\n            If True then u = (1 - u), i.e. the direction is flipped. Defaults\n            to False.\n\n    Returns:\n        (NDArray3): Numpy ndarray with shape (3,)\n\n    Raises:\n        TypeError: If u is not of type int or float.\n        ValueError: If u is not part of the number set [0 1].\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/curve/#pymesh.geo.curves.curve.Curve.get_path","title":"get_path","text":"<pre><code>get_path()\n</code></pre> <p>Returns curve path function</p> Source code in <code>pymesh/geo/curves/curve.py</code> <pre><code>def get_path(self) -&gt; Callable[[int | float, bool], NDArray3[np.float64]]:\n    \"\"\"Returns curve path function\"\"\"\n    return self.path\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/line/","title":"line","text":""},{"location":"doc-pages/auto-generated/geo/curves/line/#pymesh.geo.curves.line.Line","title":"Line","text":"<p>               Bases: <code>Curve</code></p> <p>Creates a straight line object, generated from two points in space.</p> <p>For more information, see Curve documentation.</p> Source code in <code>pymesh/geo/curves/line.py</code> <pre><code>class Line(Curve):\n    \"\"\"Creates a straight line object, generated from two points in space.\n\n    For more information, see Curve documentation.\n    \"\"\"\n\n    def __init__(self, start: Point, end: Point):\n        \"\"\"Initialization method.\n\n        Args:\n            start (Point): Line start point\n            end (Point): Line end point\n\n        Raises:\n            ValueError: If start and end points are the same.\n        \"\"\"\n        self.start = start\n        self.end = end\n        if start == end:\n            raise ValueError(\"start and end points are the same\")\n\n    def __eq__(self, other):\n        return self.start == other.start and self.end == other.end\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __repr__(self):\n        return f\"{type(self).__name__}(start={self.start!r}, end={self.end!r})\"\n\n    @property\n    def length(self) -&gt; float:\n        return np.sqrt(np.sum((self.end - self.start) ** 2))\n\n    def path(self, u: int | float, flip: bool = False) -&gt; NDArray3[np.float64]:\n        u = validate_curve_path_parameters(u, flip)\n        return self.start.xyz + (self.end - self.start) * u\n\n    def copy(self) -&gt; Self:\n        return Line(self.start.copy(), self.end.copy())\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.start.move(dx, dy, dz)\n        self.end.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.start.rotate(angle, a, b, c, x0, y0, z0)\n        self.end.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.start.mirror(a, b, c, x0, y0, z0)\n        self.end.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/line/#pymesh.geo.curves.line.Line.__init__","title":"__init__","text":"<pre><code>__init__(start, end)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Point</code> <p>Line start point</p> required <code>end</code> <code>Point</code> <p>Line end point</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If start and end points are the same.</p> Source code in <code>pymesh/geo/curves/line.py</code> <pre><code>def __init__(self, start: Point, end: Point):\n    \"\"\"Initialization method.\n\n    Args:\n        start (Point): Line start point\n        end (Point): Line end point\n\n    Raises:\n        ValueError: If start and end points are the same.\n    \"\"\"\n    self.start = start\n    self.end = end\n    if start == end:\n        raise ValueError(\"start and end points are the same\")\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/user_defined_curve/","title":"user_defined_curve","text":""},{"location":"doc-pages/auto-generated/geo/curves/user_defined_curve/#pymesh.geo.curves.user_defined_curve.UserDefinedCurve","title":"UserDefinedCurve","text":"<p>               Bases: <code>Curve</code></p> <p>Generic curve with a user defined path function.</p> <p>For more information, see Curve documentation.</p> Source code in <code>pymesh/geo/curves/user_defined_curve.py</code> <pre><code>class UserDefinedCurve(Curve):\n    \"\"\"Generic curve with a user defined path function.\n\n    For more information, see Curve documentation.\n    \"\"\"\n\n    def __init__(self, path: Callable[[int | float], NDArray3[np.float64]]):\n        \"\"\"Initialization method.\n\n        Args:\n            path (Callable): User-defined curve path function,\n                that takes a float between 0 and 1 and returns\n                a numpy.ndarray with shape (3,) and elements\n                representing the x, y and z values of the point\n                on the path corresponding to the input path ratio.\n        \"\"\"\n        result = path(0)\n        if not isinstance(result, np.ndarray):\n            raise TypeError(\n                f\"Expected path function to return a numpy ndarray, but got {result!r}\"\n            )\n        if not result.shape == (3,):\n            raise TypeError(\n                f\"Expected path function to return a numpy ndarray of shape (3,), but got {result.shape}\"\n            )\n        self._path = path\n\n    def __eq__(self, other):\n        is_equal = True\n        if type(self).__name__ != type(other).__name__:\n            is_equal = False\n        else:\n            for u in np.linspace(0, 1, num=NUM_POINTS, endpoint=True):\n                xyz1 = self.path(u)\n                xyz2 = other.path(u)\n                if not np.isclose(xyz1, xyz2, atol=TOLERANCE).all():\n                    is_equal = False\n                    break\n        return is_equal\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __repr__(self):\n        txt = f\"{type(self).__name__}(path=UserDefined)\"\n        return txt\n\n    @property\n    def start(self) -&gt; Point:\n        x, y, z = self.path(0)\n        return Point(x, y, z)\n\n    @property\n    def end(self) -&gt; Point:\n        x, y, z = self.path(1)\n        return Point(x, y, z)\n\n    @property\n    def length(self) -&gt; float:\n        distance = 0.0\n        xyz0 = self.path(0)\n        for u in np.linspace(start=0, stop=1, num=NUM_POINTS, endpoint=True):\n            xyz1 = self.path(u)\n            distance += np.sqrt(np.sum((xyz1 - xyz0) ** 2))\n            xyz0 = xyz1\n        return distance\n\n    def path(self, u: int | float, flip: bool = False) -&gt; NDArray3[np.float64]:\n        u = validate_curve_path_parameters(u, flip)\n        return self._path(u)\n\n    def copy(self) -&gt; Self:\n        return UserDefinedCurve(copy.copy(self._path))\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        _path = copy.copy(self._path)\n\n        def moved_path(u):\n            return _path(u) + np.array([dx, dy, dz])\n\n        self._path = moved_path\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        _path = copy.copy(self._path)\n\n        def rotated_path(u):\n            x, y, z = _path(u)\n            return rotate_point_xyz(x, y, z, angle, a, b, c, x0, y0, z0)\n\n        self._path = rotated_path\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        _path = copy.copy(self._path)\n\n        def mirored_path(u):\n            x, y, z = _path(u)\n            return mirror_point_xyz(x, y, z, a, b, c, x0, y0, z0)\n\n        self._path = mirored_path\n        return self\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/curves/user_defined_curve/#pymesh.geo.curves.user_defined_curve.UserDefinedCurve.__init__","title":"__init__","text":"<pre><code>__init__(path)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Callable</code> <p>User-defined curve path function, that takes a float between 0 and 1 and returns a numpy.ndarray with shape (3,) and elements representing the x, y and z values of the point on the path corresponding to the input path ratio.</p> required Source code in <code>pymesh/geo/curves/user_defined_curve.py</code> <pre><code>def __init__(self, path: Callable[[int | float], NDArray3[np.float64]]):\n    \"\"\"Initialization method.\n\n    Args:\n        path (Callable): User-defined curve path function,\n            that takes a float between 0 and 1 and returns\n            a numpy.ndarray with shape (3,) and elements\n            representing the x, y and z values of the point\n            on the path corresponding to the input path ratio.\n    \"\"\"\n    result = path(0)\n    if not isinstance(result, np.ndarray):\n        raise TypeError(\n            f\"Expected path function to return a numpy ndarray, but got {result!r}\"\n        )\n    if not result.shape == (3,):\n        raise TypeError(\n            f\"Expected path function to return a numpy ndarray of shape (3,), but got {result.shape}\"\n        )\n    self._path = path\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/","title":"surfaces","text":""},{"location":"doc-pages/auto-generated/geo/surfaces/bilinear_surface/","title":"bilinear_surface","text":""},{"location":"doc-pages/auto-generated/geo/surfaces/bilinear_surface/#pymesh.geo.surfaces.bilinear_surface.BilinearSurface","title":"BilinearSurface","text":"<p>               Bases: <code>Surface</code></p> <p>Creates a bilinear surface from the points p00, p10, p11 and p01.</p> <p>These four points represent the surface corners going counter-clockwise. The first number represents the value of u, while the second number represents the value of w.</p> <p>Attributes:</p> Name Type Description <code>p00</code> <code>Point</code> <p>Bottom-left point (u=0, w=0).</p> <code>p10</code> <code>Point</code> <p>Bottom-right point (u=1, w=0).</p> <code>p01</code> <code>Point</code> <p>Top-left point (u=0, w=1).</p> <code>p11</code> <code>Point</code> <p>Top-right point (u=1, w=1).</p> Source code in <code>pymesh/geo/surfaces/bilinear_surface.py</code> <pre><code>class BilinearSurface(Surface):\n    \"\"\"Creates a bilinear surface from the points p00, p10, p11 and p01.\n\n    These four points represent the surface corners going counter-clockwise.\n    The first number represents the value of u, while the second number\n    represents the value of w.\n\n    Attributes:\n        p00 (Point): Bottom-left point (u=0, w=0).\n        p10 (Point): Bottom-right point (u=1, w=0).\n        p01 (Point): Top-left point (u=0, w=1).\n        p11 (Point): Top-right point (u=1, w=1).\n    \"\"\"\n\n    p00 = AsInstanceOf(Point)\n    p10 = AsInstanceOf(Point)\n    p01 = AsInstanceOf(Point)\n    p11 = AsInstanceOf(Point)\n\n    def __init__(self, p00: Point, p10: Point, p11: Point, p01: Point):\n        \"\"\"Initialization method.\n\n        Args:\n            p00: Bottom-left point\n            p10: Bottom-right point\n            p01: Top-left point\n            p11: Top-right point\n\n        Raises:\n            TypeError: If p00, p10, p01 or p11 are not of type Point.\n        \"\"\"\n        self._all_surfaces.append(self)\n        self.p00 = p00\n        self.p10 = p10\n        self.p11 = p11\n        self.p01 = p01\n\n    def __eq__(self, other):\n        return (\n            self.p00 == other.p00\n            and self.p10 == other.p10\n            and self.p11 == other.p11\n            and self.p01 == other.p01\n        )\n\n    def __repr__(self):\n        return (\n            f\"{type(self).__name__}(p00={self.p00!r},\"\n            f\"p10={self.p10!r}, p11={self.p11!r}, p01={self.p01!r})\"\n        )\n\n    def path(\n        self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n    ) -&gt; NDArray3[np.float64]:\n        u, w = validate_surface_path_parameters(u, w, uflip, wflip)\n        return (\n            (1 - u) * w * self.p00.xyz\n            + u * w * self.p10.xyz\n            + (1 - u) * (1 - w) * self.p01.xyz\n            + u * (1 - w) * self.p11.xyz\n        )\n\n    def get_max_lengths(self) -&gt; tuple[float]:\n        length_u_bottom = np.sqrt(np.sum((self.p00 - self.p10) ** 2))\n        length_u_top = np.sqrt(np.sum((self.p01 - self.p11) ** 2))\n        length_w_left = np.sqrt(np.sum((self.p00 - self.p01) ** 2))\n        length_w_right = np.sqrt(np.sum((self.p10 - self.p11) ** 2))\n        length_u = float(np.max((length_u_bottom, length_u_top)))\n        length_w = float(np.max((length_w_left, length_w_right)))\n        return length_u, length_w\n\n    def copy(self) -&gt; Self:\n        copy = BilinearSurface(\n            self.p00.copy(),\n            self.p10.copy(),\n            self.p11.copy(),\n            self.p01.copy(),\n        )\n        copy._is_normal_flipped = self._is_normal_flipped\n        return copy\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.p00.move(dx, dy, dz)\n        self.p10.move(dx, dy, dz)\n        self.p11.move(dx, dy, dz)\n        self.p01.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.p00.rotate(angle, a, b, c, x0, y0, z0)\n        self.p10.rotate(angle, a, b, c, x0, y0, z0)\n        self.p11.rotate(angle, a, b, c, x0, y0, z0)\n        self.p01.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.p00.mirror(a, b, c, x0, y0, z0)\n        self.p10.mirror(a, b, c, x0, y0, z0)\n        self.p11.mirror(a, b, c, x0, y0, z0)\n        self.p01.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/bilinear_surface/#pymesh.geo.surfaces.bilinear_surface.BilinearSurface.__init__","title":"__init__","text":"<pre><code>__init__(p00, p10, p11, p01)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>p00</code> <code>Point</code> <p>Bottom-left point</p> required <code>p10</code> <code>Point</code> <p>Bottom-right point</p> required <code>p01</code> <code>Point</code> <p>Top-left point</p> required <code>p11</code> <code>Point</code> <p>Top-right point</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If p00, p10, p01 or p11 are not of type Point.</p> Source code in <code>pymesh/geo/surfaces/bilinear_surface.py</code> <pre><code>def __init__(self, p00: Point, p10: Point, p11: Point, p01: Point):\n    \"\"\"Initialization method.\n\n    Args:\n        p00: Bottom-left point\n        p10: Bottom-right point\n        p01: Top-left point\n        p11: Top-right point\n\n    Raises:\n        TypeError: If p00, p10, p01 or p11 are not of type Point.\n    \"\"\"\n    self._all_surfaces.append(self)\n    self.p00 = p00\n    self.p10 = p10\n    self.p11 = p11\n    self.p01 = p01\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/coons_patch/","title":"coons_patch","text":""},{"location":"doc-pages/auto-generated/geo/surfaces/coons_patch/#pymesh.geo.surfaces.coons_patch.CoonsPatch","title":"CoonsPatch","text":"<p>               Bases: <code>Surface</code></p> <p>Creates a Coons Patch from a selection of four curves.</p> <p>Attributes:</p> Name Type Description <code>curves</code> <code>list[Curve] | tuple[Curve]</code> <p>List or tuple with four Curve instances defining the surface boundary curves.</p> Source code in <code>pymesh/geo/surfaces/coons_patch.py</code> <pre><code>class CoonsPatch(Surface):\n    \"\"\"Creates a Coons Patch from a selection of four curves.\n\n    Attributes:\n        curves (list[Curve] | tuple[Curve]): List or tuple with four\n            Curve instances defining the surface boundary curves.\n    \"\"\"\n\n    def __init__(self, curves: list[Curve] | tuple[Curve]):\n        \"\"\"Initialization method.\n\n        Args:\n            curves: List or tuple with four Curve instances\n                defining the surface boundary curves.\n\n        Raises:\n            TypeError: If curves is not of type list or tuple.\n            ValueError: If length of curves is not equal to four.\n            TypeError: If elements of curves are not of type Curve.\n        \"\"\"\n        self._all_surfaces.append(self)\n        self.curves = curves  # also sets self._flipped_curves\n\n    def __eq__(self, other):\n        is_equal = True\n        for scurve, ocurve in zip(self.curves, other.curves):\n            if scurve != ocurve:\n                is_equal = False\n                break\n        return is_equal\n\n    def __repr__(self):\n        txt = f\"{type(self).__name__}(curves=(\"\n        for i, curve in enumerate(self.curves):\n            txt += f\"{curve!r}\"\n            txt += \"))\" if i == 3 else \", \"\n        return txt\n\n    @property\n    def curves(self) -&gt; tuple[Curve]:\n        return self._curves\n\n    @curves.setter\n    def curves(self, curves) -&gt; None:\n        pname = \"curves\"\n        if not isinstance(curves, (list, tuple)):\n            raise TypeError(f\"{pname} must receive a list or tuple input\")\n        if len(curves) != 4:\n            raise ValueError(f\"{pname} must containing exactly 4 items.\")\n        for curve in curves:\n            if not isinstance(curve, Curve):\n                raise TypeError(f\"{pname} items must be of type 'Curve'.\")\n        initial_selection = list(curves)\n        curve_selection = [initial_selection.pop(0)]\n        ref_point = curve_selection[-1].end\n        flipped_curves = [False]\n        index = 0\n        while (\n            len(curve_selection) &lt;= 4\n            and len(initial_selection) &gt;= 1\n            and index &lt; len(initial_selection)\n        ):\n            next_curve_points = (\n                initial_selection[index].start,\n                initial_selection[index].end,\n            )\n            if ref_point == next_curve_points[0] or ref_point == next_curve_points[1]:\n                if np.all(ref_point == next_curve_points[0]):\n                    # next curve has matching starting point\n                    flipped_curves.append(False)\n                    ref_point = next_curve_points[1]\n                else:\n                    # next curve has matching ending point\n                    flipped_curves.append(True)\n                    ref_point = next_curve_points[0]\n                curve_selection.append(initial_selection.pop(index))\n                index = 0\n                continue\n            index += 1\n        if ref_point != curve_selection[0].start or index &gt; len(initial_selection):\n            raise CurveIntersectionError(\n                \"Selected curves does not share intersection points\"\n            )\n        cflip, cselect = set_curve_order(flipped_curves, curve_selection)\n        self._flipped_curves = tuple(cflip)\n        self._curves = tuple(cselect)\n\n    def path(\n        self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n    ) -&gt; NDArray3[np.float64]:\n        u, w = validate_surface_path_parameters(u, w, uflip, wflip)\n        curve_u0, curve_u1, curve_0w, curve_1w = self.curves\n        fu0, fu1, f0w, f1w = self._flipped_curves\n\n        def path_u0(x):\n            return curve_u0.path(x, flip=fu0)\n\n        def path_u1(x):\n            return curve_u1.path(x, flip=fu1)\n\n        def path_0w(x):\n            return curve_0w.path(x, flip=f0w)\n\n        def path_1w(x):\n            return curve_1w.path(x, flip=f1w)\n\n        p00, p11, p01, p10 = path_u0(0), path_u1(1), path_0w(1), path_1w(0)\n        p1 = (1 - u) * path_0w(w) + u * path_1w(w)\n        p2 = (1 - w) * path_u0(u) + w * path_u1(u)\n        p3 = (\n            (1 - u) * (1 - w) * p00\n            + u * (1 - w) * p10\n            + (1 - u) * w * p01\n            + u * w * p11\n        )\n        return p1 + p2 - p3\n\n    def get_max_lengths(self) -&gt; tuple[float]:\n        curve_u0, curve_u1, curve_0w, curve_1w = self.curves\n        max_length_u = max(curve_u0.length, curve_u1.length)\n        max_length_w = max(curve_0w.length, curve_1w.length)\n        return max_length_u, max_length_w\n\n    def copy(self) -&gt; Self:\n        curve_u0, curve_u1, curve_0w, curve_1w = self.curves\n        curves_copy = (\n            curve_u0.copy(),\n            curve_u1.copy(),\n            curve_0w.copy(),\n            curve_1w.copy(),\n        )\n        copy = CoonsPatch(curves_copy)\n        copy._is_normal_flipped = self._is_normal_flipped\n        return copy\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        for curve in self.curves:\n            curve.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        for curve in self.curves:\n            curve.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        for curve in self.curves:\n            curve.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/coons_patch/#pymesh.geo.surfaces.coons_patch.CoonsPatch.__init__","title":"__init__","text":"<pre><code>__init__(curves)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>curves</code> <code>list[Curve] | tuple[Curve]</code> <p>List or tuple with four Curve instances defining the surface boundary curves.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If curves is not of type list or tuple.</p> <code>ValueError</code> <p>If length of curves is not equal to four.</p> <code>TypeError</code> <p>If elements of curves are not of type Curve.</p> Source code in <code>pymesh/geo/surfaces/coons_patch.py</code> <pre><code>def __init__(self, curves: list[Curve] | tuple[Curve]):\n    \"\"\"Initialization method.\n\n    Args:\n        curves: List or tuple with four Curve instances\n            defining the surface boundary curves.\n\n    Raises:\n        TypeError: If curves is not of type list or tuple.\n        ValueError: If length of curves is not equal to four.\n        TypeError: If elements of curves are not of type Curve.\n    \"\"\"\n    self._all_surfaces.append(self)\n    self.curves = curves  # also sets self._flipped_curves\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/coons_patch/#pymesh.geo.surfaces.coons_patch.set_curve_order","title":"set_curve_order","text":"<pre><code>set_curve_order(cflip, cselect)\n</code></pre> <p>Sets the order u0, u1, 0w, 1w where u0 = first item in cselect</p> Source code in <code>pymesh/geo/surfaces/coons_patch.py</code> <pre><code>def set_curve_order(cflip, cselect) -&gt; tuple[list]:\n    \"\"\"Sets the order u0, u1, 0w, 1w where u0 = first item in cselect\"\"\"\n    cselect = [cselect[0], cselect[2], cselect[3], cselect[1]]\n    cflip = [cflip[0], cflip[2], cflip[3], cflip[1]]\n    for index in (1, 2):\n        cflip[index] = not cflip[index]\n    return cflip, cselect\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/plane_surface/","title":"plane_surface","text":""},{"location":"doc-pages/auto-generated/geo/surfaces/plane_surface/#pymesh.geo.surfaces.plane_surface.PlaneSurface","title":"PlaneSurface","text":"<p>               Bases: <code>Surface</code></p> <p>Creates a plane surface based on three points in space.</p> <p>The plane is drawn from the vectors |point1 - point0| and |point2 - point0|, where point0 is a shared point between the two vectors.</p> <p>Attributes:</p> Name Type Description <code>point0</code> <code>Point</code> <p>Shared point between two plane defining vectors.</p> <code>point1</code> <code>Point</code> <p>Point defining the |point1-point0| vector.</p> <code>point2</code> <code>Point</code> <p>Point defining the |point2-point0| vector.</p> Source code in <code>pymesh/geo/surfaces/plane_surface.py</code> <pre><code>class PlaneSurface(Surface):\n    \"\"\"Creates a plane surface based on three points in space.\n\n    The plane is drawn from the vectors |point1 - point0| and\n    |point2 - point0|, where point0 is a shared point between\n    the two vectors.\n\n    Attributes:\n        point0 (Point): Shared point between two plane defining vectors.\n        point1 (Point): Point defining the |point1-point0| vector.\n        point2 (Point): Point defining the |point2-point0| vector.\n    \"\"\"\n\n    point0 = AsInstanceOf(Point)\n    point1 = AsInstanceOf(Point)\n    point2 = AsInstanceOf(Point)\n\n    def __init__(self, point0: Point, point1: Point, point2: Point):\n        \"\"\"Initialiation method.\n\n        Args:\n            point0: Shared point between two plane defining vectors.\n            point1: Point defining the |point1-point0| vector.\n            point2: Point defining the |point2-point0| vector.\n\n        Raises:\n            TypeError: If point0, point1 or point2 are not of type Point.\n        \"\"\"\n        self._all_surfaces.append(self)\n        self.point0 = point0\n        self.point1 = point1\n        self.point2 = point2\n\n    def __eq__(self, other):\n        return (\n            self.point0 == other.point0\n            and self.point1 == other.point1\n            and self.point2 == other.point2\n        )\n\n    def __repr__(self):\n        return (\n            f\"{type(self).__name__}(point0={self.point0!r},\"\n            f\"point1={self.point1!r}, point2={self.point2!r})\"\n        )\n\n    def path(\n        self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n    ) -&gt; NDArray3[np.float64]:\n        # ! find a way to add np.ndarray to Point using __add__\n        u, w = validate_surface_path_parameters(u, w, uflip, wflip)\n        xyz0 = self.point0.xyz\n        u_point = (self.point1 - self.point0) * u\n        w_point = (self.point2 - self.point0) * w\n        return xyz0 + u_point + w_point\n\n    def get_max_lengths(self) -&gt; tuple[float]:\n        length_u = float(np.sqrt(np.sum((self.point1 - self.point0) ** 2)))\n        length_w = float(np.sqrt(np.sum((self.point2 - self.point0) ** 2)))\n        return length_u, length_w\n\n    def copy(self) -&gt; Self:\n        copy = PlaneSurface(self.point0.copy(), self.point1.copy(), self.point2.copy())\n        copy._is_normal_flipped = self._is_normal_flipped\n        return copy\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.point0.move(dx, dy, dz)\n        self.point1.move(dx, dy, dz)\n        self.point2.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.point0.rotate(angle, a, b, c, x0, y0, z0)\n        self.point1.rotate(angle, a, b, c, x0, y0, z0)\n        self.point2.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.point0.mirror(a, b, c, x0, y0, z0)\n        self.point1.mirror(a, b, c, x0, y0, z0)\n        self.point2.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/plane_surface/#pymesh.geo.surfaces.plane_surface.PlaneSurface.__init__","title":"__init__","text":"<pre><code>__init__(point0, point1, point2)\n</code></pre> <p>Initialiation method.</p> <p>Parameters:</p> Name Type Description Default <code>point0</code> <code>Point</code> <p>Shared point between two plane defining vectors.</p> required <code>point1</code> <code>Point</code> <p>Point defining the |point1-point0| vector.</p> required <code>point2</code> <code>Point</code> <p>Point defining the |point2-point0| vector.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If point0, point1 or point2 are not of type Point.</p> Source code in <code>pymesh/geo/surfaces/plane_surface.py</code> <pre><code>def __init__(self, point0: Point, point1: Point, point2: Point):\n    \"\"\"Initialiation method.\n\n    Args:\n        point0: Shared point between two plane defining vectors.\n        point1: Point defining the |point1-point0| vector.\n        point2: Point defining the |point2-point0| vector.\n\n    Raises:\n        TypeError: If point0, point1 or point2 are not of type Point.\n    \"\"\"\n    self._all_surfaces.append(self)\n    self.point0 = point0\n    self.point1 = point1\n    self.point2 = point2\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/ruled_surface/","title":"ruled_surface","text":""},{"location":"doc-pages/auto-generated/geo/surfaces/ruled_surface/#pymesh.geo.surfaces.ruled_surface.RuledSurface","title":"RuledSurface","text":"<p>               Bases: <code>Surface</code></p> <p>Creates a ruled surface based on two opposing boundary curves.</p> <p>Attributes:</p> Name Type Description <code>curve1</code> <code>Curve</code> <p>Curve defining one surface boundary.</p> <code>curve2</code> <code>Curve</code> <p>Curve defining opposing surface boundary.</p> Source code in <code>pymesh/geo/surfaces/ruled_surface.py</code> <pre><code>class RuledSurface(Surface):\n    \"\"\"Creates a ruled surface based on two opposing boundary curves.\n\n    Attributes:\n        curve1 (Curve): Curve defining one surface boundary.\n        curve2 (Curve): Curve defining opposing surface boundary.\n    \"\"\"\n\n    curve1 = AsInstanceOf(Curve)\n    curve2 = AsInstanceOf(Curve)\n\n    def __init__(self, curve1: Curve, curve2: Curve):\n        \"\"\"Initialization method.\n\n        Args:\n            curve1: Curve defining one surface boundary.\n            curve2: Curve defining opposing surface boundary.\n\n        Raises:\n            TypeError: If curve1 or curve2 are not of type Curve.\n        \"\"\"\n        self._all_surfaces.append(self)\n        self.curve1 = curve1\n        self.curve2 = curve2\n\n    def __eq__(self, other):\n        return self.curve1 == other.curve1 and self.curve2 == other.curve2\n\n    def __repr__(self):\n        return f\"{type(self).__name__}(curve1={self.curve1!r}, curve2={self.curve2!r})\"\n\n    def get_max_lengths(self) -&gt; tuple[float]:\n        length_u = max(self.curve1.length, self.curve2.length)\n        length_w = max(\n            float(np.sqrt(np.sum((self.curve1.start - self.curve2.start) ** 2))),\n            float(np.sqrt(np.sum((self.curve1.end - self.curve2.end) ** 2))),\n        )\n        return length_u, length_w\n\n    def path(\n        self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n    ) -&gt; NDArray3[np.float64]:\n        u, w = validate_surface_path_parameters(u, w, uflip, wflip)\n        return (1 - w) * self.curve1.path(u) + w * self.curve2.path(u)\n\n    def copy(self) -&gt; Self:\n        copy = RuledSurface(self.curve1.copy(), self.curve2.copy())\n        copy._is_normal_flipped = self._is_normal_flipped\n        return copy\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.curve1.move(dx, dy, dz)\n        self.curve2.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.curve1.rotate(angle, a, b, c, x0, y0, z0)\n        self.curve2.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.curve1.mirror(a, b, c, x0, y0, z0)\n        self.curve2.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/ruled_surface/#pymesh.geo.surfaces.ruled_surface.RuledSurface.__init__","title":"__init__","text":"<pre><code>__init__(curve1, curve2)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>curve1</code> <code>Curve</code> <p>Curve defining one surface boundary.</p> required <code>curve2</code> <code>Curve</code> <p>Curve defining opposing surface boundary.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If curve1 or curve2 are not of type Curve.</p> Source code in <code>pymesh/geo/surfaces/ruled_surface.py</code> <pre><code>def __init__(self, curve1: Curve, curve2: Curve):\n    \"\"\"Initialization method.\n\n    Args:\n        curve1: Curve defining one surface boundary.\n        curve2: Curve defining opposing surface boundary.\n\n    Raises:\n        TypeError: If curve1 or curve2 are not of type Curve.\n    \"\"\"\n    self._all_surfaces.append(self)\n    self.curve1 = curve1\n    self.curve2 = curve2\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/surface/","title":"surface","text":""},{"location":"doc-pages/auto-generated/geo/surfaces/surface/#pymesh.geo.surfaces.surface.Surface","title":"Surface","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class used which all surface classes inherit from.</p> <p>Attributes:</p> Name Type Description <code>is_normal_flipped</code> <code>bool</code> <p>Specifies surface normal direction.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>class Surface(ABC):\n    \"\"\"Abstract base class used which all surface classes inherit from.\n\n    Attributes:\n        is_normal_flipped (bool): Specifies surface normal direction.\n    \"\"\"\n\n    _all_surfaces: list = []\n    _is_normal_flipped: bool = False\n\n    @property\n    def is_normal_flipped(self) -&gt; bool:\n        return self._is_normal_flipped\n\n    @classmethod\n    def get_all_surfaces(cls) -&gt; tuple[Surface]:\n        \"\"\"Returns a list of all generated surfaces, independent of surface class name.\"\"\"\n        return tuple(cls._all_surfaces)\n\n    def flip_normal(self) -&gt; Self:\n        \"\"\"Flips surface normal\"\"\"\n        self._is_normal_flipped = not self._is_normal_flipped\n        return self\n\n    @abstractmethod\n    def copy(self) -&gt; Self:\n        \"\"\"Returns a recursive copy of surface instance.\"\"\"\n\n    @abstractmethod\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        \"\"\"Moves the surface a given relative position in space.\n\n        Args:\n            dx: Distance moved in the x-direction.\n            dy: Distance moved in the y-direction.\n            dz: Distance moved in the z-direction.\n\n        Returns:\n            (Surface): Surface with updated xyz coordinates.\n\n        Raises:\n            TypeError: If dx, dy or dz are not of type int or float.\n            ValueError: If dx, dy and dz are all zero.\n        \"\"\"\n\n    @abstractmethod\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        \"\"\"Rotates surface around an axis.\n\n        Implementation based on [WikiPedia](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n\n        Args:\n            angle: Angle in radians.\n                Poitive direction defined as counter-clockwise, based on the right-hand rule.\n            a: Axis vector x direction.\n            b: Axis vector y direction.\n            c: Axis vector z direction.\n            x0: Axis base x coordinate\n                Default is zero.\n            y0: Axis base y coordinate\n                Default is zero.\n            z0: Axis base z coordinate\n                Default is zero.\n\n        Returns:\n            (Surface): Rotated surface instance.\n\n        Raises:\n            TypeError: If input value are not of type int or float.\n        \"\"\"\n\n    @abstractmethod\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        \"\"\"Mirrors surface in a plane.\n\n        Plane is defined by a plane normal vector (a, b, c) and a point (x0, y0, z0) in the plane.\n        Implementation based on formulation by [Jean Marie](https://math.stackexchange.com/questions/3927881/reflection-over-planes-in-3d).\n\n        Args:\n            a: Plane normal vector x dimension.\n            b: Plane normal vector y dimension.\n            c: Plane normal vector z dimension.\n            x0: Plane normal vector base x coordinate\n                Default is zero.\n            y0: Plane normal vector base y coordinate\n                Default is zero.\n            z0: Plane normal vector base z coordinate\n                Default is zero.\n\n        Returns:\n            (Surface): Mirrored surface instance.\n\n        Raises:\n            TypeError: If input value are not of type int or float.\n        \"\"\"\n\n    def get_path(\n        self,\n    ) -&gt; Callable[[int | float, int | float, bool, bool], NDArray3[np.float64]]:\n        \"\"\"Returns surface path function\"\"\"\n        return self.path\n\n    @abstractmethod\n    def path(\n        self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n    ) -&gt; NDArray3[np.float64]:\n        \"\"\"Surface path function that converts two normalized inputs u and w to a physical xyz point on the surface.\n\n        Args:\n            u: Normalized surface dimension path parameter between 0 and 1,\n                where 0 and 1 represents the start and end locations, respectively.\n            w: Normalized surface dimension path parameter between 0 and 1,\n                where 0 and 1 represents the start and end locations, respectively.\n            uflip: Defaults to False.\n                If True then u = (1 - u), i.e. the direction is flipped.\n            wflip: Defaults to False.\n                If True then w = (1 - w), i.e. the direction is flipped.\n\n        Returns:\n            (NDArray3[float]): Numpy ndarray with shape (3,)\n\n        Raises:\n            TypeError: If u or w are not of type int or float.\n            ValueError: If u or w are not part of the number set [0 1].\n        \"\"\"\n\n    @abstractmethod\n    def get_max_lengths(self) -&gt; tuple[float]:\n        \"\"\"Returns a tuple of shape (2,) with the longest surface\n        boundary length along each of the u and w dimensions. Indices\n        0 and 1 represent the u and w dimensions, respectively.\n        \"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/surface/#pymesh.geo.surfaces.surface.Surface.get_all_surfaces","title":"get_all_surfaces  <code>classmethod</code>","text":"<pre><code>get_all_surfaces()\n</code></pre> <p>Returns a list of all generated surfaces, independent of surface class name.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@classmethod\ndef get_all_surfaces(cls) -&gt; tuple[Surface]:\n    \"\"\"Returns a list of all generated surfaces, independent of surface class name.\"\"\"\n    return tuple(cls._all_surfaces)\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/surface/#pymesh.geo.surfaces.surface.Surface.flip_normal","title":"flip_normal","text":"<pre><code>flip_normal()\n</code></pre> <p>Flips surface normal</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>def flip_normal(self) -&gt; Self:\n    \"\"\"Flips surface normal\"\"\"\n    self._is_normal_flipped = not self._is_normal_flipped\n    return self\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/surface/#pymesh.geo.surfaces.surface.Surface.copy","title":"copy  <code>abstractmethod</code>","text":"<pre><code>copy()\n</code></pre> <p>Returns a recursive copy of surface instance.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@abstractmethod\ndef copy(self) -&gt; Self:\n    \"\"\"Returns a recursive copy of surface instance.\"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/surface/#pymesh.geo.surfaces.surface.Surface.move","title":"move  <code>abstractmethod</code>","text":"<pre><code>move(dx=0.0, dy=0.0, dz=0.0)\n</code></pre> <p>Moves the surface a given relative position in space.</p> <p>Parameters:</p> Name Type Description Default <code>dx</code> <code>int | float</code> <p>Distance moved in the x-direction.</p> <code>0.0</code> <code>dy</code> <code>int | float</code> <p>Distance moved in the y-direction.</p> <code>0.0</code> <code>dz</code> <code>int | float</code> <p>Distance moved in the z-direction.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Surface</code> <p>Surface with updated xyz coordinates.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If dx, dy or dz are not of type int or float.</p> <code>ValueError</code> <p>If dx, dy and dz are all zero.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@abstractmethod\ndef move(\n    self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n) -&gt; Self:\n    \"\"\"Moves the surface a given relative position in space.\n\n    Args:\n        dx: Distance moved in the x-direction.\n        dy: Distance moved in the y-direction.\n        dz: Distance moved in the z-direction.\n\n    Returns:\n        (Surface): Surface with updated xyz coordinates.\n\n    Raises:\n        TypeError: If dx, dy or dz are not of type int or float.\n        ValueError: If dx, dy and dz are all zero.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/surface/#pymesh.geo.surfaces.surface.Surface.rotate","title":"rotate  <code>abstractmethod</code>","text":"<pre><code>rotate(angle, a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Rotates surface around an axis.</p> <p>Implementation based on WikiPedia.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>int | float</code> <p>Angle in radians. Poitive direction defined as counter-clockwise, based on the right-hand rule.</p> required <code>a</code> <code>int | float</code> <p>Axis vector x direction.</p> required <code>b</code> <code>int | float</code> <p>Axis vector y direction.</p> required <code>c</code> <code>int | float</code> <p>Axis vector z direction.</p> required <code>x0</code> <code>int | float</code> <p>Axis base x coordinate Default is zero.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Axis base y coordinate Default is zero.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Axis base z coordinate Default is zero.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Surface</code> <p>Rotated surface instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input value are not of type int or float.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@abstractmethod\ndef rotate(\n    self,\n    angle: int | float,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; Self:\n    \"\"\"Rotates surface around an axis.\n\n    Implementation based on [WikiPedia](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula).\n\n    Args:\n        angle: Angle in radians.\n            Poitive direction defined as counter-clockwise, based on the right-hand rule.\n        a: Axis vector x direction.\n        b: Axis vector y direction.\n        c: Axis vector z direction.\n        x0: Axis base x coordinate\n            Default is zero.\n        y0: Axis base y coordinate\n            Default is zero.\n        z0: Axis base z coordinate\n            Default is zero.\n\n    Returns:\n        (Surface): Rotated surface instance.\n\n    Raises:\n        TypeError: If input value are not of type int or float.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/surface/#pymesh.geo.surfaces.surface.Surface.mirror","title":"mirror  <code>abstractmethod</code>","text":"<pre><code>mirror(a, b, c, x0=0.0, y0=0.0, z0=0.0)\n</code></pre> <p>Mirrors surface in a plane.</p> <p>Plane is defined by a plane normal vector (a, b, c) and a point (x0, y0, z0) in the plane. Implementation based on formulation by Jean Marie.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | float</code> <p>Plane normal vector x dimension.</p> required <code>b</code> <code>int | float</code> <p>Plane normal vector y dimension.</p> required <code>c</code> <code>int | float</code> <p>Plane normal vector z dimension.</p> required <code>x0</code> <code>int | float</code> <p>Plane normal vector base x coordinate Default is zero.</p> <code>0.0</code> <code>y0</code> <code>int | float</code> <p>Plane normal vector base y coordinate Default is zero.</p> <code>0.0</code> <code>z0</code> <code>int | float</code> <p>Plane normal vector base z coordinate Default is zero.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Surface</code> <p>Mirrored surface instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input value are not of type int or float.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@abstractmethod\ndef mirror(\n    self,\n    a: int | float,\n    b: int | float,\n    c: int | float,\n    x0: int | float = 0.0,\n    y0: int | float = 0.0,\n    z0: int | float = 0.0,\n) -&gt; Self:\n    \"\"\"Mirrors surface in a plane.\n\n    Plane is defined by a plane normal vector (a, b, c) and a point (x0, y0, z0) in the plane.\n    Implementation based on formulation by [Jean Marie](https://math.stackexchange.com/questions/3927881/reflection-over-planes-in-3d).\n\n    Args:\n        a: Plane normal vector x dimension.\n        b: Plane normal vector y dimension.\n        c: Plane normal vector z dimension.\n        x0: Plane normal vector base x coordinate\n            Default is zero.\n        y0: Plane normal vector base y coordinate\n            Default is zero.\n        z0: Plane normal vector base z coordinate\n            Default is zero.\n\n    Returns:\n        (Surface): Mirrored surface instance.\n\n    Raises:\n        TypeError: If input value are not of type int or float.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/surface/#pymesh.geo.surfaces.surface.Surface.get_path","title":"get_path","text":"<pre><code>get_path()\n</code></pre> <p>Returns surface path function</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>def get_path(\n    self,\n) -&gt; Callable[[int | float, int | float, bool, bool], NDArray3[np.float64]]:\n    \"\"\"Returns surface path function\"\"\"\n    return self.path\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/surface/#pymesh.geo.surfaces.surface.Surface.path","title":"path  <code>abstractmethod</code>","text":"<pre><code>path(u, w, uflip=False, wflip=False)\n</code></pre> <p>Surface path function that converts two normalized inputs u and w to a physical xyz point on the surface.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>int | float</code> <p>Normalized surface dimension path parameter between 0 and 1, where 0 and 1 represents the start and end locations, respectively.</p> required <code>w</code> <code>int | float</code> <p>Normalized surface dimension path parameter between 0 and 1, where 0 and 1 represents the start and end locations, respectively.</p> required <code>uflip</code> <code>bool</code> <p>Defaults to False. If True then u = (1 - u), i.e. the direction is flipped.</p> <code>False</code> <code>wflip</code> <code>bool</code> <p>Defaults to False. If True then w = (1 - w), i.e. the direction is flipped.</p> <code>False</code> <p>Returns:</p> Type Description <code>NDArray3[float]</code> <p>Numpy ndarray with shape (3,)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If u or w are not of type int or float.</p> <code>ValueError</code> <p>If u or w are not part of the number set [0 1].</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@abstractmethod\ndef path(\n    self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n) -&gt; NDArray3[np.float64]:\n    \"\"\"Surface path function that converts two normalized inputs u and w to a physical xyz point on the surface.\n\n    Args:\n        u: Normalized surface dimension path parameter between 0 and 1,\n            where 0 and 1 represents the start and end locations, respectively.\n        w: Normalized surface dimension path parameter between 0 and 1,\n            where 0 and 1 represents the start and end locations, respectively.\n        uflip: Defaults to False.\n            If True then u = (1 - u), i.e. the direction is flipped.\n        wflip: Defaults to False.\n            If True then w = (1 - w), i.e. the direction is flipped.\n\n    Returns:\n        (NDArray3[float]): Numpy ndarray with shape (3,)\n\n    Raises:\n        TypeError: If u or w are not of type int or float.\n        ValueError: If u or w are not part of the number set [0 1].\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/surface/#pymesh.geo.surfaces.surface.Surface.get_max_lengths","title":"get_max_lengths  <code>abstractmethod</code>","text":"<pre><code>get_max_lengths()\n</code></pre> <p>Returns a tuple of shape (2,) with the longest surface boundary length along each of the u and w dimensions. Indices 0 and 1 represent the u and w dimensions, respectively.</p> Source code in <code>pymesh/geo/surfaces/surface.py</code> <pre><code>@abstractmethod\ndef get_max_lengths(self) -&gt; tuple[float]:\n    \"\"\"Returns a tuple of shape (2,) with the longest surface\n    boundary length along each of the u and w dimensions. Indices\n    0 and 1 represent the u and w dimensions, respectively.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/swept_surface/","title":"swept_surface","text":""},{"location":"doc-pages/auto-generated/geo/surfaces/swept_surface/#pymesh.geo.surfaces.swept_surface.SweptSurface","title":"SweptSurface","text":"<p>               Bases: <code>Surface</code></p> <p>Creates a swept surface from a curve and a sweeper curve.</p> <p>Attributes:</p> Name Type Description <code>curve</code> <code>Curve</code> <p>Curve defining the path to be swept.</p> <code>sweeper</code> <code>Curve</code> <p>Curve defining the path curve is swept along.</p> Source code in <code>pymesh/geo/surfaces/swept_surface.py</code> <pre><code>class SweptSurface(Surface):\n    \"\"\"Creates a swept surface from a curve and a sweeper curve.\n\n    Attributes:\n        curve (Curve): Curve defining the path to be swept.\n        sweeper (Curve): Curve defining the path curve is swept along.\n    \"\"\"\n\n    curve = AsInstanceOf(Curve)\n    sweeper = AsInstanceOf(Curve)\n\n    def __init__(self, curve: Curve, sweeper: Curve):\n        \"\"\"Initialization method.\n\n        Args:\n            curve: Curve defining the path to be swept.\n            sweeper: Curve defining the path curve is swept along.\n\n        Raises:\n            TypeError: If curve or sweeper are not of type Curve.\n        \"\"\"\n        self._all_surfaces.append(self)\n        self.curve = curve\n        self.sweeper = sweeper\n\n    def __eq__(self, other):\n        return self.curve == other.curve and self.sweeper == other.sweeper\n\n    def __repr__(self):\n        return f\"{type(self).__name__}(curve={self.curve!r}, sweeper={self.sweeper!r})\"\n\n    def get_max_lengths(self) -&gt; tuple[float]:\n        return self.curve.length, self.sweeper.length\n\n    def path(\n        self, u: int | float, w: int | float, uflip: bool = False, wflip: bool = False\n    ) -&gt; NDArray3[np.float64]:\n        u, w = validate_surface_path_parameters(u, w, uflip, wflip)\n        sweep = self.sweeper.path(w) - self.sweeper.path(0)\n        return self.curve.path(u) + sweep\n\n    def copy(self) -&gt; Self:\n        copy = SweptSurface(self.curve.copy(), self.sweeper.copy())\n        copy._is_normal_flipped = self._is_normal_flipped\n        return copy\n\n    def move(\n        self, dx: int | float = 0.0, dy: int | float = 0.0, dz: int | float = 0.0\n    ) -&gt; Self:\n        self.curve.move(dx, dy, dz)\n        self.sweeper.move(dx, dy, dz)\n        return self\n\n    def rotate(\n        self,\n        angle: int | float,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.curve.rotate(angle, a, b, c, x0, y0, z0)\n        self.sweeper.rotate(angle, a, b, c, x0, y0, z0)\n        return self\n\n    def mirror(\n        self,\n        a: int | float,\n        b: int | float,\n        c: int | float,\n        x0: int | float = 0.0,\n        y0: int | float = 0.0,\n        z0: int | float = 0.0,\n    ) -&gt; Self:\n        self.curve.mirror(a, b, c, x0, y0, z0)\n        self.sweeper.mirror(a, b, c, x0, y0, z0)\n        return self\n</code></pre>"},{"location":"doc-pages/auto-generated/geo/surfaces/swept_surface/#pymesh.geo.surfaces.swept_surface.SweptSurface.__init__","title":"__init__","text":"<pre><code>__init__(curve, sweeper)\n</code></pre> <p>Initialization method.</p> <p>Parameters:</p> Name Type Description Default <code>curve</code> <code>Curve</code> <p>Curve defining the path to be swept.</p> required <code>sweeper</code> <code>Curve</code> <p>Curve defining the path curve is swept along.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If curve or sweeper are not of type Curve.</p> Source code in <code>pymesh/geo/surfaces/swept_surface.py</code> <pre><code>def __init__(self, curve: Curve, sweeper: Curve):\n    \"\"\"Initialization method.\n\n    Args:\n        curve: Curve defining the path to be swept.\n        sweeper: Curve defining the path curve is swept along.\n\n    Raises:\n        TypeError: If curve or sweeper are not of type Curve.\n    \"\"\"\n    self._all_surfaces.append(self)\n    self.curve = curve\n    self.sweeper = sweeper\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/","title":"mesh","text":""},{"location":"doc-pages/auto-generated/mesh/mesh_distributions/","title":"mesh_distributions","text":""},{"location":"doc-pages/auto-generated/mesh/mesh_distributions/#pymesh.mesh.mesh_distributions.MeshDistribution","title":"MeshDistribution","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract mesh distribution base class.</p> See also <ul> <li>LinearDistribution</li> <li>CosineDistribution</li> <li>PowerDistribution</li> <li>ExponentialDistribution</li> </ul> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>class MeshDistribution(ABC):\n    \"\"\"Abstract mesh distribution base class.\n\n    See also:\n        - [LinearDistribution][pymesh.mesh.mesh_distributions.LinearDistribution]\n        - [CosineDistribution][pymesh.mesh.mesh_distributions.CosineDistribution]\n        - [PowerDistribution][pymesh.mesh.mesh_distributions.PowerDistribution]\n        - [ExponentialDistribution][pymesh.mesh.mesh_distributions.ExponentialDistribution]\n    \"\"\"\n\n    def __init__(self, flip_direction: bool = False):\n        self.flip_direction = flip_direction\n\n    def __repr__(self) -&gt; str:\n        return self.__class__.__name__\n\n    @property\n    def flip_direction(self) -&gt; bool:\n        return self._flip_direction\n\n    @flip_direction.setter\n    def flip_direction(self, value) -&gt; None:\n        if not isinstance(value, bool):\n            raise TypeError(\"flip_direction must be of type 'bool'\")\n        self._flip_direction = value\n\n    @abstractmethod\n    def copy(self) -&gt; Self:\n        \"\"\"Returns a copy of self\"\"\"\n\n    @abstractmethod\n    def get_dist_fn(self, flip_direction: bool):\n        \"\"\"Returns distribution function which takes a single float from 0 to 1\n        and returns a float between 0 and 1 according to the distribution type.\n        \"\"\"\n\n    @staticmethod\n    def flip_exp(exp, flip_direction: bool):\n        \"\"\"Flips 'exp' to '1.0 - exp' if flip_direction is True\"\"\"\n        if not flip_direction:\n            return exp\n        return 1.0 - exp\n\n    @staticmethod\n    def validate_fn_input(u: int | float, flip_direction: bool) -&gt; float:\n        \"\"\"Validates type of inputs u and flip_direction\"\"\"\n        if not isinstance(flip_direction, bool):\n            raise TypeError(\"flip_direction mus be of type 'bool'\")\n        if not isinstance(u, (int, float)):\n            raise TypeError(\"u must be of type 'int' or 'float'\")\n        if isinstance(u, int):\n            u = float(u)\n        if u &lt; 0 or u &gt; 1:\n            raise ValueError(\"u must be a value between 0 and 1\")\n        if flip_direction:\n            u = 1.0 - u\n        return u\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/mesh_distributions/#pymesh.mesh.mesh_distributions.MeshDistribution.copy","title":"copy  <code>abstractmethod</code>","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of self</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>@abstractmethod\ndef copy(self) -&gt; Self:\n    \"\"\"Returns a copy of self\"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/mesh_distributions/#pymesh.mesh.mesh_distributions.MeshDistribution.get_dist_fn","title":"get_dist_fn  <code>abstractmethod</code>","text":"<pre><code>get_dist_fn(flip_direction)\n</code></pre> <p>Returns distribution function which takes a single float from 0 to 1 and returns a float between 0 and 1 according to the distribution type.</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>@abstractmethod\ndef get_dist_fn(self, flip_direction: bool):\n    \"\"\"Returns distribution function which takes a single float from 0 to 1\n    and returns a float between 0 and 1 according to the distribution type.\n    \"\"\"\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/mesh_distributions/#pymesh.mesh.mesh_distributions.MeshDistribution.flip_exp","title":"flip_exp  <code>staticmethod</code>","text":"<pre><code>flip_exp(exp, flip_direction)\n</code></pre> <p>Flips 'exp' to '1.0 - exp' if flip_direction is True</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>@staticmethod\ndef flip_exp(exp, flip_direction: bool):\n    \"\"\"Flips 'exp' to '1.0 - exp' if flip_direction is True\"\"\"\n    if not flip_direction:\n        return exp\n    return 1.0 - exp\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/mesh_distributions/#pymesh.mesh.mesh_distributions.MeshDistribution.validate_fn_input","title":"validate_fn_input  <code>staticmethod</code>","text":"<pre><code>validate_fn_input(u, flip_direction)\n</code></pre> <p>Validates type of inputs u and flip_direction</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>@staticmethod\ndef validate_fn_input(u: int | float, flip_direction: bool) -&gt; float:\n    \"\"\"Validates type of inputs u and flip_direction\"\"\"\n    if not isinstance(flip_direction, bool):\n        raise TypeError(\"flip_direction mus be of type 'bool'\")\n    if not isinstance(u, (int, float)):\n        raise TypeError(\"u must be of type 'int' or 'float'\")\n    if isinstance(u, int):\n        u = float(u)\n    if u &lt; 0 or u &gt; 1:\n        raise ValueError(\"u must be a value between 0 and 1\")\n    if flip_direction:\n        u = 1.0 - u\n    return u\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/mesh_distributions/#pymesh.mesh.mesh_distributions.LinearDistribution","title":"LinearDistribution","text":"<p>               Bases: <code>MeshDistribution</code></p> <p>Linear path distribution class expression: fn(u) = u</p> <p>For more information, see MeshDistribution.</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>class LinearDistribution(MeshDistribution):\n    \"\"\"Linear path distribution class\n    expression: fn(u) = u\n\n    For more information, see [MeshDistribution][pymesh.mesh.mesh_distributions.MeshDistribution].\n    \"\"\"\n\n    def __init__(self, flip_direction: bool = False):\n        super().__init__(flip_direction=flip_direction)\n\n    def copy(self) -&gt; Self:\n        return LinearDistribution(self.flip_direction)\n\n    def get_dist_fn(self):\n        flip = True if self.flip_direction else False  # breaks ref to self\n\n        def fn(u: int | float, flip_direction: bool = flip) -&gt; float:\n            u = self.validate_fn_input(u=u, flip_direction=flip_direction)\n            exp = u\n            return self.flip_exp(exp, flip_direction)\n\n        return fn\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/mesh_distributions/#pymesh.mesh.mesh_distributions.CosineDistribution","title":"CosineDistribution","text":"<p>               Bases: <code>MeshDistribution</code></p> <p>Cosine path distribution class expression: fn(u) = cos[(u-1)*pi/2]</p> <p>For more information, see MeshDistribution.</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>class CosineDistribution(MeshDistribution):\n    \"\"\"Cosine path distribution class\n    expression: fn(u) = cos[(u-1)*pi/2]\n\n    For more information, see [MeshDistribution][pymesh.mesh.mesh_distributions.MeshDistribution].\n    \"\"\"\n\n    def __init__(self, flip_direction: bool = False):\n        super().__init__(flip_direction=flip_direction)\n\n    def copy(self) -&gt; Self:\n        return CosineDistribution(self.flip_direction)\n\n    def get_dist_fn(self):\n        flip = True if self.flip_direction else False  # breaks ref to self\n\n        def fn(u: int | float, flip_direction: bool = flip) -&gt; float:\n            u = self.validate_fn_input(u=u, flip_direction=flip_direction)\n            exp = math.cos((u - 1.0) * math.pi / 2)\n            return self.flip_exp(exp, flip_direction)\n\n        return fn\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/mesh_distributions/#pymesh.mesh.mesh_distributions.ExponentialDistribution","title":"ExponentialDistribution","text":"<p>               Bases: <code>MeshDistribution</code></p> <p>Exponential path distribution class expression: fn(u) = exp[ratio*u]</p> <p>For more information, see MeshDistribution.</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>class ExponentialDistribution(MeshDistribution):\n    \"\"\"Exponential path distribution class\n    expression: fn(u) = exp[ratio*u]\n\n    For more information, see [MeshDistribution][pymesh.mesh.mesh_distributions.MeshDistribution].\n    \"\"\"\n\n    ratio = AsNumber(return_type=float)\n\n    def __init__(self, ratio: int | float = 1.0, flip_direction: bool = False):\n        super().__init__(flip_direction=flip_direction)\n        self.ratio = ratio\n\n    def copy(self) -&gt; Self:\n        return ExponentialDistribution(self.ratio, self.flip_direction)\n\n    def get_dist_fn(self):\n        flip = True if self.flip_direction else False  # breaks ref to self\n\n        def fn(u: int | float, flip_direction: bool = flip) -&gt; float:\n            u = self.validate_fn_input(u=u, flip_direction=flip_direction)\n            exp = (math.exp(self.ratio * u) - 1.0) / (math.exp(self.ratio * 1.0) - 1.0)\n            return self.flip_exp(exp, flip_direction)\n\n        return fn\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/mesh_distributions/#pymesh.mesh.mesh_distributions.PowerDistribution","title":"PowerDistribution","text":"<p>               Bases: <code>MeshDistribution</code></p> <p>Power path distribution class expression: fn(u) = u**power expression: fn(u) = u</p> <p>For more information, see MeshDistribution.</p> Source code in <code>pymesh/mesh/mesh_distributions.py</code> <pre><code>class PowerDistribution(MeshDistribution):\n    \"\"\"Power path distribution class\n    expression: fn(u) = u**power\n    expression: fn(u) = u\n\n    For more information, see [MeshDistribution][pymesh.mesh.mesh_distributions.MeshDistribution].\n    \"\"\"\n\n    power = AsNumber(return_type=float)\n\n    def __init__(self, power: int | float = 1.0, flip_direction: bool = False):\n        super().__init__(flip_direction=flip_direction)\n        self.power = power\n\n    def copy(self) -&gt; Self:\n        return PowerDistribution(self.power, self.flip_direction)\n\n    def get_dist_fn(self):\n        flip = True if self.flip_direction else False  # breaks ref to self\n\n        def fn(u: int | float, flip_direction: bool = flip) -&gt; float:\n            u = self.validate_fn_input(u=u, flip_direction=flip_direction)\n            exp = u**self.power\n            return self.flip_exp(exp, flip_direction)\n\n        return fn\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/mesh_generator/","title":"mesh_generator","text":""},{"location":"doc-pages/auto-generated/mesh/mesh_generator/#pymesh.mesh.mesh_generator.MeshGenerator","title":"MeshGenerator","text":"<p>Mesh generator class.</p> <p>Attributes:</p> Name Type Description <code>surfaces</code> <code>list[dict]</code> <p>List of surface dictionaries with mesh information.</p> Source code in <code>pymesh/mesh/mesh_generator.py</code> <pre><code>class MeshGenerator:\n    \"\"\"Mesh generator class.\n\n    Attributes:\n        surfaces: List of surface dictionaries with mesh information.\n    \"\"\"\n\n    surfaces: list[dict] = []\n    \"\"\"List of surface dictionaries with mesh information.\n\n    Each surface dictionary follows the structure:\n\n    .. code-block:: python3\n        surface = {\n            \"path\": Callable[[float], NDArray3],\n            \"flipped_normal\": bool,\n            \"num_points\": tuple[int],\n            \"distributions\": tuple[MeshDistribution],\n        }\n\n    Note:\n        Above code block works in Visual Studio Code.\n    \"\"\"\n\n    def add_surface(\n        self,\n        surface: Surface,\n        density_u: int | float = 0.2,\n        density_w: int | float = 0.2,\n        distribution_u: MeshDistribution = LinearDistribution(),\n        distribution_w: MeshDistribution = LinearDistribution(),\n    ) -&gt; None:\n        \"\"\"Adds a surface to the mesh.\n\n        Args:\n            surface: Surface object to be added.\n            density_u: Panel density along the u dimension.\n                Integer values represent the number of panels,\n                while float values represent panel size.\n            density_w: Panel density along the w dimension.\n                Integer values represent the number of panels,\n                while float values represent panel size.\n            distribution_u: Distribution type along the u dimension.\n            distribution_w: Distribution type along the w dimension.\n\n        Examples:\n            Initialize a mesh and add a surface with two panels (linearly distributed\n            by default) along the u dimension and a panel length of 0.1 units along\n            the w dimension. These panels are distributed exponentially.\n\n            &gt;&gt;&gt; surface = PlaneSurface(Point(0, 0, 0), Point(1, 0, 0), Point(0, 1, 0))\n            &gt;&gt;&gt; dist_exp = ExponentialDistribution()\n            &gt;&gt;&gt; mesh = MeshGenerator()\n            &gt;&gt;&gt; mesh.add_surface(surface, density_u=2, density_w=0.1, distribution_w=dist_exp)\n\n            The user is referred to [pymesh.mesh.mesh_distributions][] for more\n            information on distribution_u and distribution_w options.\n\n        Note:\n            Above example code block style works with MkDocs, but does not look nice\n            in Visual Studio Code.\n        \"\"\"\n        length_u, length_w = surface.get_max_lengths()\n        num_points_u = self.get_num_points(length_u, density_u)\n        num_points_w = self.get_num_points(length_w, density_w)\n        data = {\n            \"path\": surface.get_path(),\n            \"flipped_normal\": surface.is_normal_flipped,\n            \"num_points\": (num_points_u, num_points_w),\n            \"distributions\": (distribution_u, distribution_w),\n        }\n        self.surfaces.append(data)\n\n    @staticmethod\n    def get_num_points(length: float, density: int | float) -&gt; int:\n        \"\"\"Returns number of points along a dimension.\n\n        Args:\n            length: Lagest length of relevant surface boundary curves.\n            density: Panel density along the dimension.\n                Integer values represent the number of panels,\n                while float values represent panel size.\n\n        Returns:\n            num_points: Nummber of points needed along surface dimension.\n        \"\"\"\n        num_points = density + 1\n        if isinstance(density, float):\n            num_points = int(np.ceil(length / density) + 1)\n        return num_points\n\n    @staticmethod\n    def _generate_mesh_points(mesh) -&gt; NDArray3xNxN[np.float64]:\n        \"\"\"Generates mesh points\"\"\"\n        path = mesh[\"path\"]\n        num_points_u, num_points_w = mesh[\"num_points\"]\n        distribution_u, distribution_w = mesh[\"distributions\"]\n        ufn = distribution_u.get_dist_fn()\n        wfn = distribution_w.get_dist_fn()\n        mp = np.zeros((3, num_points_u, num_points_w))\n        for i, u in enumerate(np.linspace(0, 1, num=num_points_u, endpoint=True)):\n            for j, w in enumerate(np.linspace(0, 1, num=num_points_w, endpoint=True)):\n                mp[:, i, j] = path(ufn(u), wfn(w))\n        return mp\n\n    @staticmethod\n    def _generate_panels(\n        mesh_points: NDArray3xNxN[np.float64], flipped_normal: bool\n    ) -&gt; list[list[float]]:\n        \"\"\"Returns list of quadrilateral panels.\n\n        Each panel is defined as a list of 12 floating numbers,\n        representing the xyz coordinates of the four panel vertices:\n        panel = [x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3]\n        \"\"\"\n        panels = []\n        mp = mesh_points\n        for j in range(0, mp.shape[2] - 1):\n            for i in range(0, mp.shape[1] - 1):\n                xyz1 = mp[:, i, j]\n                xyz2 = mp[:, i + 1, j]\n                xyz3 = mp[:, i + 1, j + 1]\n                xyz4 = mp[:, i, j + 1]\n                if flipped_normal:\n                    xyz1, xyz2, xyz3, xyz4 = xyz4, xyz3, xyz2, xyz1\n                panels.append(\n                    [\n                        xyz1[0],\n                        xyz1[1],\n                        xyz1[2],\n                        xyz2[0],\n                        xyz2[1],\n                        xyz2[2],\n                        xyz3[0],\n                        xyz3[1],\n                        xyz3[2],\n                        xyz4[0],\n                        xyz4[1],\n                        xyz4[2],\n                    ]\n                )\n        return panels\n\n    def get_panels(self) -&gt; list[list[float]]:\n        \"\"\"Generates and returns panels for each item in the surfaces attribute list.\n\n        Returns:\n            panels: List of quadrilateral panels.\n                Each panel is defined as a list of 12 floating numbers,\n                representing the xyz coordinates of the four panel vertices:\n                panel = [x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3].\n        \"\"\"\n        panels = []\n        for data in self.surfaces:\n            mesh_points = self._generate_mesh_points(data)\n            surface_panels = self._generate_panels(mesh_points, data[\"flipped_normal\"])\n            panels += surface_panels\n        return panels\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/mesh_generator/#pymesh.mesh.mesh_generator.MeshGenerator.surfaces","title":"surfaces  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>surfaces = []\n</code></pre> <p>List of surface dictionaries with mesh information.</p> <p>Each surface dictionary follows the structure:</p> <p>.. code-block:: python3     surface = {         \"path\": Callable[[float], NDArray3],         \"flipped_normal\": bool,         \"num_points\": tuple[int],         \"distributions\": tuple[MeshDistribution],     }</p> Note <p>Above code block works in Visual Studio Code.</p>"},{"location":"doc-pages/auto-generated/mesh/mesh_generator/#pymesh.mesh.mesh_generator.MeshGenerator.add_surface","title":"add_surface","text":"<pre><code>add_surface(surface, density_u=0.2, density_w=0.2, distribution_u=LinearDistribution(), distribution_w=LinearDistribution())\n</code></pre> <p>Adds a surface to the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>surface</code> <code>Surface</code> <p>Surface object to be added.</p> required <code>density_u</code> <code>int | float</code> <p>Panel density along the u dimension. Integer values represent the number of panels, while float values represent panel size.</p> <code>0.2</code> <code>density_w</code> <code>int | float</code> <p>Panel density along the w dimension. Integer values represent the number of panels, while float values represent panel size.</p> <code>0.2</code> <code>distribution_u</code> <code>MeshDistribution</code> <p>Distribution type along the u dimension.</p> <code>LinearDistribution()</code> <code>distribution_w</code> <code>MeshDistribution</code> <p>Distribution type along the w dimension.</p> <code>LinearDistribution()</code> <p>Examples:</p> <p>Initialize a mesh and add a surface with two panels (linearly distributed by default) along the u dimension and a panel length of 0.1 units along the w dimension. These panels are distributed exponentially.</p> <pre><code>&gt;&gt;&gt; surface = PlaneSurface(Point(0, 0, 0), Point(1, 0, 0), Point(0, 1, 0))\n&gt;&gt;&gt; dist_exp = ExponentialDistribution()\n&gt;&gt;&gt; mesh = MeshGenerator()\n&gt;&gt;&gt; mesh.add_surface(surface, density_u=2, density_w=0.1, distribution_w=dist_exp)\n</code></pre> <p>The user is referred to pymesh.mesh.mesh_distributions for more information on distribution_u and distribution_w options.</p> Note <p>Above example code block style works with MkDocs, but does not look nice in Visual Studio Code.</p> Source code in <code>pymesh/mesh/mesh_generator.py</code> <pre><code>def add_surface(\n    self,\n    surface: Surface,\n    density_u: int | float = 0.2,\n    density_w: int | float = 0.2,\n    distribution_u: MeshDistribution = LinearDistribution(),\n    distribution_w: MeshDistribution = LinearDistribution(),\n) -&gt; None:\n    \"\"\"Adds a surface to the mesh.\n\n    Args:\n        surface: Surface object to be added.\n        density_u: Panel density along the u dimension.\n            Integer values represent the number of panels,\n            while float values represent panel size.\n        density_w: Panel density along the w dimension.\n            Integer values represent the number of panels,\n            while float values represent panel size.\n        distribution_u: Distribution type along the u dimension.\n        distribution_w: Distribution type along the w dimension.\n\n    Examples:\n        Initialize a mesh and add a surface with two panels (linearly distributed\n        by default) along the u dimension and a panel length of 0.1 units along\n        the w dimension. These panels are distributed exponentially.\n\n        &gt;&gt;&gt; surface = PlaneSurface(Point(0, 0, 0), Point(1, 0, 0), Point(0, 1, 0))\n        &gt;&gt;&gt; dist_exp = ExponentialDistribution()\n        &gt;&gt;&gt; mesh = MeshGenerator()\n        &gt;&gt;&gt; mesh.add_surface(surface, density_u=2, density_w=0.1, distribution_w=dist_exp)\n\n        The user is referred to [pymesh.mesh.mesh_distributions][] for more\n        information on distribution_u and distribution_w options.\n\n    Note:\n        Above example code block style works with MkDocs, but does not look nice\n        in Visual Studio Code.\n    \"\"\"\n    length_u, length_w = surface.get_max_lengths()\n    num_points_u = self.get_num_points(length_u, density_u)\n    num_points_w = self.get_num_points(length_w, density_w)\n    data = {\n        \"path\": surface.get_path(),\n        \"flipped_normal\": surface.is_normal_flipped,\n        \"num_points\": (num_points_u, num_points_w),\n        \"distributions\": (distribution_u, distribution_w),\n    }\n    self.surfaces.append(data)\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/mesh_generator/#pymesh.mesh.mesh_generator.MeshGenerator.get_num_points","title":"get_num_points  <code>staticmethod</code>","text":"<pre><code>get_num_points(length, density)\n</code></pre> <p>Returns number of points along a dimension.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>float</code> <p>Lagest length of relevant surface boundary curves.</p> required <code>density</code> <code>int | float</code> <p>Panel density along the dimension. Integer values represent the number of panels, while float values represent panel size.</p> required <p>Returns:</p> Name Type Description <code>num_points</code> <code>int</code> <p>Nummber of points needed along surface dimension.</p> Source code in <code>pymesh/mesh/mesh_generator.py</code> <pre><code>@staticmethod\ndef get_num_points(length: float, density: int | float) -&gt; int:\n    \"\"\"Returns number of points along a dimension.\n\n    Args:\n        length: Lagest length of relevant surface boundary curves.\n        density: Panel density along the dimension.\n            Integer values represent the number of panels,\n            while float values represent panel size.\n\n    Returns:\n        num_points: Nummber of points needed along surface dimension.\n    \"\"\"\n    num_points = density + 1\n    if isinstance(density, float):\n        num_points = int(np.ceil(length / density) + 1)\n    return num_points\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/mesh_generator/#pymesh.mesh.mesh_generator.MeshGenerator.get_panels","title":"get_panels","text":"<pre><code>get_panels()\n</code></pre> <p>Generates and returns panels for each item in the surfaces attribute list.</p> <p>Returns:</p> Name Type Description <code>panels</code> <code>list[list[float]]</code> <p>List of quadrilateral panels. Each panel is defined as a list of 12 floating numbers, representing the xyz coordinates of the four panel vertices: panel = [x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3].</p> Source code in <code>pymesh/mesh/mesh_generator.py</code> <pre><code>def get_panels(self) -&gt; list[list[float]]:\n    \"\"\"Generates and returns panels for each item in the surfaces attribute list.\n\n    Returns:\n        panels: List of quadrilateral panels.\n            Each panel is defined as a list of 12 floating numbers,\n            representing the xyz coordinates of the four panel vertices:\n            panel = [x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3].\n    \"\"\"\n    panels = []\n    for data in self.surfaces:\n        mesh_points = self._generate_mesh_points(data)\n        surface_panels = self._generate_panels(mesh_points, data[\"flipped_normal\"])\n        panels += surface_panels\n    return panels\n</code></pre>"},{"location":"doc-pages/auto-generated/mesh/mesh_viewer/","title":"mesh_viewer","text":"<p>Module containing MshViewer class</p>"},{"location":"doc-pages/auto-generated/mesh/mesh_viewer/#pymesh.mesh.mesh_viewer.MeshViewer","title":"MeshViewer","text":"<p>Plots surface panels and normals using matplotlib with seaborn-v0_8 style</p> Source code in <code>pymesh/mesh/mesh_viewer.py</code> <pre><code>class MeshViewer:\n    \"\"\"Plots surface panels and normals using matplotlib with seaborn-v0_8 style\"\"\"\n\n    def __init__(self, mesh: MeshGenerator) -&gt; None:\n        self.panels = mesh.get_panels()\n        self.include_vertex_annotation = False\n        self.facecolor = \"#0072BD\"\n        self.edgecolor = \"black\"\n        self.linewidth = 0.5\n        self.alpha = 0.8\n        self.include_normals = True\n        self.normallength = 0.2\n        self.normalcolor = \"grey\"\n        self.xyzlim = np.array([1, 1, 1])\n        plt.close(\"all\")\n        mpl_style.use(\"seaborn-v0_8\")\n        fig = plt.figure()\n        fig.patch.set_facecolor(\"#EAEAF2\")\n        ax = fig.add_subplot(projection=\"3d\")\n        ax.set_xlabel(\"X axis\")\n        ax.set_ylabel(\"Y axis\")\n        ax.set_zlabel(\"Z axis\")\n        self._ax = ax\n\n    @property\n    def normallength(self) -&gt; float | None:\n        return self._normallength\n\n    @normallength.setter\n    def normallength(self, val) -&gt; None:\n        if not isinstance(val, (int, float)):\n            if not val is None:\n                raise TypeError(f\"Expected {val!r} to be int or float\")\n        if isinstance(val, int):\n            val = float(val)\n        self._normallength = val\n\n    @property\n    def ax(self):\n        return self._ax\n\n    @property\n    def xyzlim(self) -&gt; NDArray3:\n        return self._xyzlim\n\n    @xyzlim.setter\n    def xyzlim(self, value: NDArray3):\n        if not isinstance(value, np.ndarray):\n            raise TypeError(\"xyzlim must be of type 'ndarray'\")\n        if not value.shape == (3,):\n            raise TypeError(\"xyzlim must have shape (3,)\")\n        self._xyzlim = np.ceil(value)\n\n    def _plot_panels(self) -&gt; None:\n        for panel in self.panels:\n            xyz = np.array([panel[0:3], panel[3:6], panel[6:9], panel[9:12]])\n            self.__update_axis_limits(xyz)\n            if self.include_vertex_annotation:\n                self.ax.scatter(xyz[:, 0], xyz[:, 1], xyz[:, 2], color=\"blue\")\n                for i in range(0, xyz.shape[0]):\n                    self.ax.text(xyz[i, 0], xyz[i, 1], xyz[i, 2], f\"{i+1}\", color=\"k\")\n            if self.include_normals:\n                self._plot_normals(panel, colors=self.normalcolor)\n            verts = [list(zip(panel[0::3], panel[1::3], panel[2::3]))]\n            self.ax.add_collection3d(\n                Poly3DCollection(\n                    verts,\n                    facecolors=self.facecolor,\n                    linewidths=self.linewidth,\n                    edgecolors=self.edgecolor,\n                    alpha=self.alpha,\n                )\n            )\n\n    def __update_axis_limits(self, xyz):\n        x = np.max(np.abs(xyz[:, 0]))\n        y = np.max(np.abs(xyz[:, 1]))\n        z = np.max(np.abs(xyz[:, 2]))\n        xyzlim = np.max([self.xyzlim, np.array([x, y, z])], axis=0)\n        self.xyzlim = xyzlim\n\n    def _plot_normals(self, panel: list, colors: str) -&gt; None:\n        panel = np.array(panel)\n        xyz1, xyz2, xyz3, xyz4 = panel[0:3], panel[3:6], panel[6:9], panel[9:12]\n        point = np.average([xyz1, xyz2, xyz3, xyz4], axis=0)\n        cross_product = np.cross(xyz2 - xyz1, xyz4 - xyz1)\n        x, y, z = point[0], point[1], point[2]\n        u, v, w = cross_product[0], cross_product[1], cross_product[2]\n        self.ax.quiver(\n            x,\n            y,\n            z,\n            u,\n            v,\n            w,\n            length=self.normallength,\n            normalize=True,\n            colors=colors,\n        )\n\n    def _set_axis_limits(self) -&gt; None:\n        \"\"\"Sets axis limits according to xyzlim if include_normal is False.\n        Otherwise, uses the ax.axis(\"image\") algortihm.\n\n        This is done to make sure panels without normals are shown correctly.\n        However, ax.axis(\"image\") screws up with .normal_length visually.\n        \"\"\"\n        xlim, ylim, zlim = self.xyzlim\n        self.ax.set(xlim=(-np.ceil(xlim), np.ceil(xlim)))\n        self.ax.set(ylim=(-np.ceil(ylim), np.ceil(ylim)))\n        self.ax.set(zlim=(-np.ceil(zlim), np.ceil(zlim)))\n        if self.include_normals:\n            self.ax.axis(\"image\")\n\n    def show(self) -&gt; None:\n        self._plot_panels()\n        self._set_axis_limits()\n        plt.show()\n</code></pre>"},{"location":"doc-pages/auto-generated/writers/","title":"writers","text":""},{"location":"doc-pages/auto-generated/writers/gdf_writer/","title":"gdf_writer","text":"<p>Module containing GDFWriter class</p>"},{"location":"doc-pages/auto-generated/writers/gdf_writer/#pymesh.writers.gdf_writer.GDFWriter","title":"GDFWriter","text":"<p>Writes surface panels to filename with the extension 'gdf'.</p> <p>For information regarding the file formatting, refer to Section 6.1 in the WAMIT Manual.</p> <p>Attributes:</p> Name Type Description <code>ulen</code> <code>float</code> <p>unit length</p> <code>grav</code> <code>float</code> <p>gravitational constant</p> <code>isx</code> <code>bool</code> <p>symmetry in x=0. If True, the x = 0 plane is a geometric plane of symmetry. If False, the x = 0 plane is not a geometric plane of symmetry.</p> <code>isy</code> <code>bool</code> <p>symmetry in y=0. If True, the y = 0 plane is a geometric plane of symmetry. If False, the y = 0 plane is not a geometric plane of symmetry.</p> <code>header</code> <code>str</code> <p>header line in output file</p> Source code in <code>pymesh/writers/gdf_writer.py</code> <pre><code>class GDFWriter:\n    \"\"\"Writes surface panels to filename with the extension 'gdf'.\n\n    For information regarding the file formatting, refer to Section 6.1\n    in the [WAMIT Manual](https://www.wamit.com/manual7.x/v75_manual.pdf).\n\n    Attributes:\n        ulen (float): unit length\n        grav (float): gravitational constant\n        isx (bool): symmetry in x=0.\n            If True, the x = 0 plane is a geometric plane of symmetry.\n            If False, the x = 0 plane is *not* a geometric plane of symmetry.\n        isy (bool): symmetry in y=0.\n            If True, the y = 0 plane is a geometric plane of symmetry.\n            If False, the y = 0 plane is *not* a geometric plane of symmetry.\n        header (str): header line in output file\n    \"\"\"\n\n    def __init__(\n        self,\n        mesh: MeshGenerator,\n        ulen: float = 1.0,\n        grav: float = 9.816,\n        isx: bool = False,\n        isy: bool = False,\n        header: str = None,\n    ) -&gt; None:\n        self.panels = mesh.get_panels()\n        self.ulen = ulen\n        self.grav = grav\n        self.isx = isx\n        self.isy = isy\n        if header is None:\n            header = \"auto-generated using the pymesh package\"\n        self.header = header\n\n    @property\n    def header(self) -&gt; str:\n        return self._header\n\n    @header.setter\n    def header(self, value: str) -&gt; None:\n        if not isinstance(value, str):\n            raise TypeError(\"header must be of type 'str'\")\n        if len(value) &gt; 72:\n            raise ValueError(\"header text string is more than 72 characters\")\n        self._header = value\n\n    @property\n    def ulen(self) -&gt; float:\n        return self._ulen\n\n    @ulen.setter\n    def ulen(self, value: float) -&gt; None:\n        if not isinstance(value, float):\n            raise TypeError(\"ulen must be of type 'float'\")\n        if value &lt;= 0:\n            raise ValueError(\"ulen must be positive\")\n        self._ulen = value\n\n    @property\n    def grav(self) -&gt; float:\n        return self._grav\n\n    @grav.setter\n    def grav(self, value: float) -&gt; None:\n        if not isinstance(value, float):\n            raise TypeError(\"grav must be of type 'float'\")\n        if value &lt;= 0:\n            raise ValueError(\"grav must be positive\")\n        self._grav = value\n\n    @property\n    def isx(self) -&gt; bool:\n        return self._isx\n\n    @isx.setter\n    def isx(self, value: bool) -&gt; None:\n        if not isinstance(value, bool):\n            raise TypeError(\"isx must be of type 'bool'\")\n        self._isx = value\n\n    @property\n    def isy(self) -&gt; bool:\n        return self._isy\n\n    @isy.setter\n    def isy(self, value: bool) -&gt; None:\n        if not isinstance(value, bool):\n            raise TypeError(\"isy must be of type 'bool'\")\n        self._isy = value\n\n    def write(self, filename: Path):\n        \"\"\"Writes surface panels to file.\n\n        Args:\n            filename (Path): Filename path without extention.\n        \"\"\"\n        self.__validate_filename(filename)\n        with open(filename, \"w+\", encoding=\"utf-8\") as file:\n            file.write(f\"{self.header}\\n\")\n            file.write(f\"{self.ulen:f} {self.grav:f}\\n\")\n            file.write(f\"{self.isx:.0f} {self.isy:.0f}\\n\")\n            npan = len(self.panels)\n            file.write(f\"{npan:.0f}\\n\")\n            for panel in self.panels:\n                txt = \"\"\n                for i, coord in enumerate(panel):\n                    txt_space = \"\" if i == 0 else \" \"\n                    txt += f\"{txt_space}{coord:+.4e}\"\n                file.write(f\"{txt}\\n\")\n\n    def __validate_filename(self, filename: Path) -&gt; None:\n        if not isinstance(filename, Path):\n            raise TypeError(\"filename musth be of type 'Path'\")\n        if not self.__is_gdf(filename):\n            raise TypeError(\"filename must have the extension '.gdf'\")\n\n    def __is_gdf(self, filename) -&gt; bool:\n        _, extension = os.path.splitext(filename)\n        extension = extension.lower()\n        return extension == \".gdf\"\n</code></pre>"},{"location":"doc-pages/auto-generated/writers/gdf_writer/#pymesh.writers.gdf_writer.GDFWriter.write","title":"write","text":"<pre><code>write(filename)\n</code></pre> <p>Writes surface panels to file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>Filename path without extention.</p> required Source code in <code>pymesh/writers/gdf_writer.py</code> <pre><code>def write(self, filename: Path):\n    \"\"\"Writes surface panels to file.\n\n    Args:\n        filename (Path): Filename path without extention.\n    \"\"\"\n    self.__validate_filename(filename)\n    with open(filename, \"w+\", encoding=\"utf-8\") as file:\n        file.write(f\"{self.header}\\n\")\n        file.write(f\"{self.ulen:f} {self.grav:f}\\n\")\n        file.write(f\"{self.isx:.0f} {self.isy:.0f}\\n\")\n        npan = len(self.panels)\n        file.write(f\"{npan:.0f}\\n\")\n        for panel in self.panels:\n            txt = \"\"\n            for i, coord in enumerate(panel):\n                txt_space = \"\" if i == 0 else \" \"\n                txt += f\"{txt_space}{coord:+.4e}\"\n            file.write(f\"{txt}\\n\")\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Sections on installation coming soon.</p>"},{"location":"getting-started/package-at-a-glance/","title":"Package at a Glance","text":"<p>The package is based on object-oriented programming and generates three-dimentional geometry objects, such as points, curves, surfaces and a mesh.</p>"},{"location":"getting-started/package-at-a-glance/#a-simple-example","title":"A Simple Example","text":""},{"location":"getting-started/package-at-a-glance/#creating-the-mesh-geometry","title":"Creating the mesh geometry","text":"pymesh/examples/vertical-cylinder.py<pre><code>from pymesh import Point, Line, Arc3P, SweptSurface\nfrom pymesh import MeshGenerator, MeshViewer, GDFWriter\n\n# Create 3D points based on x, y and z values\np1 = Point(0, 0, 0)\np2 = Point(1, 0, 0)\np3 = Point(0, 1, 0)\np4 = Point(0, 0, 1)\n\n# Create the curves from the points\narc = Arc3P(centre=p1, start=p2, end=p3)\nline = Line(start=p1, end=p4)\n\n# Create a surface from the curves\nsurface = SweptSurface(curve=arc, sweeper=line)\n\n# Initialize the mesh and add the surface to it\nmesh = MeshGenerator()\nmesh.add_surface(surface)\n</code></pre>"},{"location":"getting-started/package-at-a-glance/#inspecting-the-mesh","title":"Inspecting the mesh","text":"<p>A <code>MeshViewer</code>, based on the <code>matplotlib</code> package, is used to conveniently plot and inspect the surface panels and their normals as shown below.</p> <pre><code># Inspect geometry\nviewer = MeshViewer(mesh)\nviewer.show()\n</code></pre> <p></p>"},{"location":"getting-started/package-at-a-glance/#write-the-mesh-to-a-geometric-data-file","title":"Write the mesh to a geometric data file","text":"<p>The <code>GDFWriter</code> takes care of converting the surfaces into a usable .gdf file.</p> <pre><code>from pathlib import Path\n\n# Write geometry to a gdf file\nwriter = GDFWriter(mesh)\nwriter.write(filename=Path(\"output\", \"simple-example.gdf\"))\n</code></pre> <p>Above code generates the following text file. For information regarding <code>GDFWriter</code> file formatting, the reader is referred to Section 6.1 in the WAMIT Manual.</p> <pre><code>auto-generated using the pymesh package\n1.000000 9.816000\n0 0\n40\n-1.0000e+00 +0.0000e+00 +0.0000e+00 -9.8079e-01 -1.9509e-01 +0.0000e+00 -9.8079e-01 -1.9509e-01 +2.0000e-01 -1.0000e+00 +0.0000e+00 +2.0000e-01\n-9.8079e-01 -1.9509e-01 +0.0000e+00 -9.2388e-01 -3.8268e-01 +0.0000e+00 -9.2388e-01 -3.8268e-01 +2.0000e-01 -9.8079e-01 -1.9509e-01 +2.0000e-01\n-9.2388e-01 -3.8268e-01 +0.0000e+00 -8.3147e-01 -5.5557e-01 +0.0000e+00 -8.3147e-01 -5.5557e-01 +2.0000e-01 -9.2388e-01 -3.8268e-01 +2.0000e-01\n-8.3147e-01 -5.5557e-01 +0.0000e+00 -7.0711e-01 -7.0711e-01 +0.0000e+00 -7.0711e-01 -7.0711e-01 +2.0000e-01 -8.3147e-01 -5.5557e-01 +2.0000e-01\n-7.0711e-01 -7.0711e-01 +0.0000e+00 -5.5557e-01 -8.3147e-01 +0.0000e+00 -5.5557e-01 -8.3147e-01 +2.0000e-01 -7.0711e-01 -7.0711e-01 +2.0000e-01\n-5.5557e-01 -8.3147e-01 +0.0000e+00 -3.8268e-01 -9.2388e-01 +0.0000e+00 -3.8268e-01 -9.2388e-01 +2.0000e-01 -5.5557e-01 -8.3147e-01 +2.0000e-01\n-3.8268e-01 -9.2388e-01 +0.0000e+00 -1.9509e-01 -9.8079e-01 +0.0000e+00 -1.9509e-01 -9.8079e-01 +2.0000e-01 -3.8268e-01 -9.2388e-01 +2.0000e-01\n-1.9509e-01 -9.8079e-01 +0.0000e+00 -6.1232e-17 -1.0000e+00 +0.0000e+00 -6.1232e-17 -1.0000e+00 +2.0000e-01 -1.9509e-01 -9.8079e-01 +2.0000e-01\n...\n</code></pre>"},{"location":"getting-started/examples/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Simple Example</li> <li>Vertical Cylinder</li> </ul>"},{"location":"getting-started/examples/simple-example/","title":"Simple Example","text":"pymesh/examples/simple-example.py<pre><code>from pathlib import Path\n\nfrom pymesh import Point, Line, Arc3P, SweptSurface\nfrom pymesh import MeshGenerator, MeshViewer, GDFWriter\n\n# Create 3D points based on x, y and z values\np1 = Point(0, 0, 0)\np2 = Point(1, 0, 0)\np3 = Point(0, 1, 0)\np4 = Point(0, 0, 1)\n\n# Create the curves from the points\narc = Arc3P(centre=p1, start=p2, end=p3)\nline = Line(start=p1, end=p4)\n\n# Create a surface from the curves\nsurface = SweptSurface(curve=arc, sweeper=line)\n\n# Initialize the mesh and add the surface to it\nmesh = MeshGenerator()\nmesh.add_surface(surface)\n\n# Inspect the mesh geometry\nviewer = MeshViewer(mesh)\nviewer.show()\n\n# Write mesh to a geometric data file\nwriter = GDFWriter(mesh)\nwriter.write(filename=Path(\"output\", \"simple-example.gdf\"))\n</code></pre>"},{"location":"getting-started/examples/vertical-cylinder/","title":"Vertical Cylinder","text":"pymesh/examples/vertical-cylinder.py<pre><code>import math\nfrom pathlib import Path\n\nfrom pymesh import Point, Line, Arc3P, ArcPVA, PlaneSurface, RuledSurface, SweptSurface\nfrom pymesh import MeshGenerator, ExponentialDistribution\nfrom pymesh import MeshViewer, GDFWriter\n\nDIAMETER = 2.0\nRATIO = 0.4\nDEPTH = 1\n\n# Create one quarter of the circle plate inner part\npoint00 = Point(0, 0, -DEPTH)\npoint10 = Point(RATIO * DIAMETER / 2, 0, -DEPTH)\npoint01 = Point(0, RATIO * DIAMETER / 2, -DEPTH)\nPlaneSurface(point00, point10, point01).flip_normal()\n\n# Create one quarter of the circle plate outer part\npoint11 = Point(RATIO * DIAMETER / 2, RATIO * DIAMETER / 2, -DEPTH)\npoint11c = Point(DIAMETER / 2 / math.sqrt(2), DIAMETER / 2 / math.sqrt(2), -DEPTH)\npoint10c = Point(DIAMETER / 2, 0, -DEPTH)\npoint01c = Point(0, DIAMETER / 2, -DEPTH)\nline10 = Line(point10, point11)\narc10 = Arc3P(point00, point10c, point11c)\nRuledSurface(line10, arc10).copy().mirror(a=-1, b=-1, c=0).flip_normal()\n\n# Create a full circular plate by copying and rotating existing surfaces\nfor surface in RuledSurface.get_all_surfaces():\n    for angle in (90, 180, 270):\n        surface.copy().rotate(angle * math.pi / 180, a=0, b=0, c=1)\n\n# Add surfaces to the mesh generator and set mesh settings\nmesh = MeshGenerator()\nfor surface in RuledSurface.get_all_surfaces():\n    mesh.add_surface(surface, density_u=0.2, density_w=0.2)\n\n# Create cylinder surface\ncircle = ArcPVA(Point(DIAMETER / 2, 0, -DEPTH), 2 * math.pi, a=0, b=0, c=1)\nline = Line(Point(0, 0, -DEPTH), Point(0, 0, 0))\nsurface_cylinder = SweptSurface(circle, line)\n\n# Add cylinder surface to the mesh generator and set mesh settings\nmesh.add_surface(\n    surface_cylinder,\n    density_u=0.2,  # float indicating panel length\n    density_w=4,  # int specifying numper of panels\n    distribution_w=ExponentialDistribution(flip_direction=True),\n)\n\n# Inspect the mesh geometry\nviewer = MeshViewer(mesh)\nviewer.show()\n\n# Write mesh to a geometric data file\nwriter = GDFWriter(mesh)\nwriter.write(filename=Path(\"output\", \"vertical-cylinder.gdf\"))\n</code></pre>"},{"location":"getting-started/how-to-guides/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Mesh Settings</li> <li>User-Defined Curve</li> <li>Using Symetry Planes</li> </ul>"},{"location":"getting-started/how-to-guides/mesh-settings/","title":"Mesh Settings","text":"<p>How-To-Guide coming soon.</p> <p>The guide should inform about the following:</p> <ul> <li>How to set the options when using the <code>add_surface</code> method</li> </ul>"},{"location":"getting-started/how-to-guides/symmetry/","title":"Using Symetry Planes","text":"<p>How-To-Guide coming soon.</p> <p>The guide should inform about the following:</p> <ul> <li>Writing gdf file using the <code>isx</code> and <code>isy</code> attributes.</li> <li>Mesh generation using the <code>mirror</code> method.</li> </ul>"},{"location":"getting-started/how-to-guides/symmetry/#utilizing-symmetry-when-writing-gdf-file","title":"Utilizing Symmetry When Writing GDF File","text":"pymesh/examples/simple-symmetry-example.py<pre><code>import math\nfrom pathlib import Path\n\nfrom pymesh import Point, PlaneSurface\nfrom pymesh import MeshGenerator, MeshViewer, GDFWriter\n\n# Create bottom plate in the plane z=0\np000 = Point(0, 0, 0)\np100 = Point(1, 0, 0)\np010 = Point(0, 1, 0)\nsurface_z0 = PlaneSurface(p000, p010, p100)\n\n# Create side plate in the plane x=1\np110 = Point(1, 1, 0)\np111 = Point(1, 1, 1)\nsurface_x1 = PlaneSurface(p110, p111, p100)\n\n# Create side plate in the plane y=1\nsurface_y1 = PlaneSurface(p110, p010, p111)\n\n# Add surfaces to the mesh generator and set mesh settings\nmesh = MeshGenerator()\nfor surface in [surface_z0 surface_x1, surface_y1]:\n    mesh.add_surface(\n        surface,\n        density_u=1,  # int specifies number of panels\n        density_w=1,  # int specifies number of panels\n    )\n\n# Inspect the mesh geometry\nviewer = MeshViewer(mesh)\nviewer.show()\n\n# Write mesh to a geometric data file\nwriter = GDFWriter(mesh)\nwriter.isx = True\nwriter.isy = True\nwriter.write(filename=Path(\"output\", \"simple-symmetry-example.gdf\"))\n</code></pre>"},{"location":"getting-started/how-to-guides/symmetry/#inspecting-the-geometry","title":"Inspecting the Geometry","text":"<p>Note</p> <p>Number of panels are not correct. There should be only 3 in total.</p> <p></p>"},{"location":"getting-started/how-to-guides/symmetry/#resulting-gdf-file","title":"Resulting GDF File","text":"<pre><code>auto-generated using the pymesh package\n1.000000 9.816000\n1 1\n3\n+0.0000e+00 +0.0000e+00 +0.0000e+00 +0.0000e+00 +1.0000e+00 +0.0000e+00 +1.0000e+00 +1.0000e+00 +0.0000e+00 +1.0000e+00 +0.0000e+00 +0.0000e+00\n+1.0000e+00 +1.0000e+00 +0.0000e+00 +1.0000e+00 +1.0000e+00 +1.0000e+00 +1.0000e+00 +0.0000e+00 +1.0000e+00 +1.0000e+00 +0.0000e+00 +0.0000e+00\n+1.0000e+00 +1.0000e+00 +0.0000e+00 +0.0000e+00 +1.0000e+00 +0.0000e+00 +0.0000e+00 +1.0000e+00 +1.0000e+00 +1.0000e+00 +1.0000e+00 +1.0000e+00\n</code></pre>"},{"location":"getting-started/how-to-guides/symmetry/#utilizing-symmetry-when-creating-panel-mesh","title":"Utilizing Symmetry When Creating Panel Mesh","text":"<p>Section coming soon.</p>"},{"location":"getting-started/how-to-guides/user-defined-curve/","title":"User-Defined Curve","text":"<p>How-To-Guide coming soon.</p> <p>The guide should inform about the following:</p> <ul> <li>How to set the options when using the <code>UserDefinedCurve</code> class.</li> </ul>"}]}